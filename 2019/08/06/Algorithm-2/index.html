<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>《算法图解》学习笔记：中部 | Ain't A Thing</title><meta name="description" content="中部内容：快速排序"><meta name="keywords" content="Algorithm,图书"><meta name="author" content="Lucas Chan"><meta name="copyright" content="Lucas Chan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://bingobounce.github.io/2019/08/06/Algorithm-2/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="《算法图解》学习笔记：中部"><meta name="twitter:description" content="中部内容：快速排序"><meta name="twitter:image" content="https://bingobounce.github.io/img/algorithm.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《算法图解》学习笔记：中部"><meta property="og:url" content="https://bingobounce.github.io/2019/08/06/Algorithm-2/"><meta property="og:site_name" content="Ain't A Thing"><meta property="og:description" content="中部内容：快速排序"><meta property="og:image" content="https://bingobounce.github.io/img/algorithm.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="每日一记： 第2话" href="https://bingobounce.github.io/2019/08/07/note-2/"><link rel="next" title="每日一记： 第1话" href="https://bingobounce.github.io/2019/08/05/note-1/"><meta name="google-site-verification" content="4Wddu4-AT6-v7UmSZOl4zCV1QKyMs9I5Bbf4GEfHptg"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-iv-快速排序"><span class="toc-number">1.</span> <span class="toc-text"> Chapter Ⅳ 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分而治之"><span class="toc-number">1.1.</span> <span class="toc-text"> 分而治之</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧几里得算法"><span class="toc-number">1.2.</span> <span class="toc-text"> 欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#another-example-数组元素和"><span class="toc-number">1.3.</span> <span class="toc-text"> Another example: 数组元素和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">1.4.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python实现"><span class="toc-number">1.5.</span> <span class="toc-text"> python实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再谈大o表示法"><span class="toc-number">1.6.</span> <span class="toc-text"> 再谈大O表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-v-散列表"><span class="toc-number">2.</span> <span class="toc-text"> Chapter Ⅴ 散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#散列表的引入"><span class="toc-number">2.1.</span> <span class="toc-text"> 散列表的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#散列函数"><span class="toc-number">2.2.</span> <span class="toc-text"> 散列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际用途"><span class="toc-number">2.3.</span> <span class="toc-text"> 实际用途</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-网站解析"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 1. 网站解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-避免重复"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 2. 避免重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-将散列表用作缓存"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 3. 将散列表用作缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冲突"><span class="toc-number">2.4.</span> <span class="toc-text"> 冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能"><span class="toc-number">2.5.</span> <span class="toc-text"> 性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#填装因子"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 填装因子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#良好的散列函数"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 良好的散列函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">2.6.</span> <span class="toc-text"> 小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充sha算法"><span class="toc-number">2.7.</span> <span class="toc-text"> 🔐  补充——SHA算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回顾"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较文件"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 比较文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检查密码"><span class="toc-number">2.7.3.</span> <span class="toc-text"> 检查密码</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/algorithm.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ain't A Thing</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> Message</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《算法图解》学习笔记：中部</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-08-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-08-08</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a></span><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6.4k</span><span class="post-meta__separator">|</span><span>Reading time: 20 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="chapter-iv-快速排序"><a class="markdownIt-Anchor" href="#chapter-iv-快速排序"></a> Chapter Ⅳ 快速排序</h2>
<p>本章主要探索<strong>分而治之</strong>（divide and conquer，D&amp;C）——一种著名的递归式问题解决方法。</p>
<h3 id="分而治之"><a class="markdownIt-Anchor" href="#分而治之"></a> 分而治之</h3>
<p>假设我们有一块土地，现在要将这块地<strong>均匀</strong>地分成<strong>方块</strong>，且分出的方块要尽可能大。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092349.png" alt></p>
<p>而下图中的分法都不太合适：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092446.png" alt></p>
<p>为了解决这个问题，我们可以使用D&amp;C策略。D&amp;C算法是递归的，其过程包括两个步骤：</p>
<ol>
<li>找出基线条件，这种条件必须尽可能简单。</li>
<li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li>
</ol>
<p>对于这个问题，我们先找出基线条件。因为要将土地均匀分为方块，最容易处理的情况是，一条边的长度是另一条边的整数倍：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092820.png" alt></p>
<p>对于一块长50米，宽25米的土地，我们可以将这样土地分为两块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>25</mn><mi>m</mi><mo>×</mo><mn>25</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">25m\times 25m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span></span></span></span>的方块。</p>
<p>现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须<br>
缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出<strong>这块地可容纳的最大方块</strong>。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806093136.png" alt></p>
<p>以大土地的宽度640m为边长，可以得到两个最大的方块，同时余下一小块地。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806093433.png" alt></p>
<p>我们将这两个最大方块可直接分为许多个大小均匀的方块。而对于剩下的土地，我们又可以使用相同的方法来划分，以此类推，就形成了一个递归问题。换言之，你将均匀划分$1680 m×640 m $土地的问题，简化成了均匀划分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>640</mn><mi>m</mi><mo>×</mo><mn>400</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">640 m×400 m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>土地的问题！</p>
<p>我们再以最大宽度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">400m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>为边长，对剩下土地划分，于是又剩下一块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn><mi>m</mi><mo>×</mo><mn>240</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">400m\times 240m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>的土地，以此递归：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100107.png" alt></p>
<p>最终获得问题的答案!</p>
<hr>
<h3 id="欧几里得算法"><a class="markdownIt-Anchor" href="#欧几里得算法"></a> 欧几里得算法</h3>
<p>在&quot;分而治之&quot;小节中引入了一种思想： <em>适用于这小块地的最大方块，也是适用于整块地的最大方块</em>。这个思想的原理来自欧几里得算法(The Euclidean Algorithm).</p>
<p>欧几里德算法是一种快速查找两个整数的最大公因数the Greatest Common Divisor (GCD) 的技术。</p>
<p>算法的步骤如下：</p>
<ul>
<li>
<p>假设现在我们需要寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>,即A、B的最大公因数。</p>
<ul>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,这是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(0,B)=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,则我们可以终止算法.</p>
</li>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,这是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,0)=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,则我们可以终止算法.</p>
</li>
<li>
<p>写出A关于B的一个商余的式子(<strong>算术余子式</strong>)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mo separator="true">⋅</mo><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">A=B·Q+R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>.</p>
</li>
<li>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=\mathrm{GCD}(B,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>,则我们只需对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(B,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>使用欧几里得算法，即可找出A,B的gcd.</p>
</li>
</ul>
</li>
</ul>
<p>欧几里得算法利用性质:<strong>If A = B⋅Q + R and B≠0 then GCD(A,B) = GCD(B,R)</strong> ,迅速地将问题简化为越来越简单的问题，直到利用前两个性质中的一个很容易地解决为止。</p>
<p>而这个性质的证明可汗学院提供了一种非常直观的方式来解决<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806095603.png" alt></p>
<blockquote></blockquote>
<hr>
<h3 id="another-example-数组元素和"><a class="markdownIt-Anchor" href="#another-example-数组元素和"></a> Another example: 数组元素和</h3>
<p>给定一个数字数组：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，我们想使用递归函数来解决问题。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100512.png" alt></p>
<blockquote>
<p>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是<strong>空数组</strong>或只包含<strong>一个元素的数组</strong>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100610.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100711.png" alt></p>
<p>🔑 <strong>提示</strong>： 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时， 请检查基线条件是不是这样的。</p>
<hr>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806104747.png" alt></p>
<p>先使用数组第一个元素作为基准值，然后找出比基准值小的元素和比基准值大的元素。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806104944.png" alt></p>
<p>这个操作称为<strong>分区</strong>(partitioning).现在我们获得了：</p>
<ul>
<li>一个由所有小于基准值的数字组成的子数组；</li>
<li>一个由所有大于基准值的数组组成的子数组；</li>
<li>基准值</li>
</ul>
<p>在进行分区后，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105124.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105515.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105626.png" alt></p>
<p>理解快速排序大致过程后，我们可能会疑问<strong>基准值</strong>如何选取呢？</p>
<p>其实将任何元素用作基准值都可行:</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105825.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105836.png" alt></p>
<p>因此我们能够对包含五个元素的数组进行排序。同理，也能够对包含六个元素的数组进行排序，以此类推。</p>
<hr>
<h3 id="python实现"><a class="markdownIt-Anchor" href="#python实现"></a> python实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr <span class="comment"># 基线条件：数组为空或只包含一个元素的数组是“有序”的</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 递归过程</span></span><br><span class="line">        pivot = arr[<span class="number">0</span>] <span class="comment"># 选取数组第一个元素基准值</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot] <span class="comment"># 比基准值小的元素组成一个数组</span></span><br><span class="line">        greater [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot] <span class="comment"># 比基准值大的元素组成一个数组</span></span><br><span class="line">        <span class="comment"># 返回数组</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="再谈大o表示法"><a class="markdownIt-Anchor" href="#再谈大o表示法"></a> 再谈大O表示法</h3>
<p>快速排序的独特之处在于，其速度取决于选择的<strong>基准值</strong>。在讨论快速排序的运行时间前，我<br>
们再来看看最常见的大O运行时间。</p>
<p>假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112444.png" alt></p>
<p>注意，数组并没有被分成两半，相反，<strong>其中一个子数组始终为空，这导致调用栈非常长</strong>。现在假设你总是将<strong>中间的元素</strong>用作基准值，在这种情况下，调用栈如下。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112552.png" alt></p>
<p>现在来看看栈的第一层。你将一个元素用作基准值，并将其他的元素划分到两个子数组中。这涉及数组中的全部8个元素，因此该操作的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。在调用栈的第一层，涉及全部8个元素， 但实际上，在调用栈的每层都涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个元素。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112835.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806113023.png" alt></p>
<p>在这个示例中，层数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>（用技术术语说，<strong>调用栈的高度</strong>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>），而每层需要的<br>
时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。因此整个算法需要的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) * O(\log n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。这就是最佳情况。 在最糟情况下，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>层，因此该算法的运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) * O(n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>最佳情况其实也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。快速排序是最快的排序算法之一，也是D&amp;C典范。</p>
<hr>
<h2 id="chapter-v-散列表"><a class="markdownIt-Anchor" href="#chapter-v-散列表"></a> Chapter Ⅴ 散列表</h2>
<h3 id="散列表的引入"><a class="markdownIt-Anchor" href="#散列表的引入"></a> 散列表的引入</h3>
<p>假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。</p>
<p>如果本子中内容没有按字母顺序排列，那么我们可能就要一行行查找了，这样的时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>了。如果本子内容是按照字母顺序排列的，那么可以使用二分查找来寻找，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>但是，如果我们能够记住所有商品价格，这样就不需要查找了，一个商品对应一个价格，即问即答，这样我们报出任何商品的价格的时间都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>为了存储商品及其价格，我们可以使用前面学习到的数据结构——数组。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808095544.png" alt></p>
<p>数组的每个元素包含两项内容：商品名和价格。如果将这个数组按商品名排序，就可使用二分查找在其中查找商品的价格。这样查找价格的时间将为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。然而，我们更加希望查找商品价格的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，那么散列函数就有用武之地了。</p>
<hr>
<h3 id="散列函数"><a class="markdownIt-Anchor" href="#散列函数"></a> 散列函数</h3>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808095718.png" alt></p>
<p>然后，散列数列输入和输出之间必须满足一些要求：</p>
<ul>
<li>它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。</li>
<li>它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</li>
</ul>
<p>下面就展示散列函数的魅力：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808100123.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808100243.png" alt></p>
<p>散列函数准确地指出了价格的存储位置，我们根本不用查找！而散列函数原理如下：</p>
<ul>
<li>散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。</li>
<li>散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。</li>
<li>散列函数知道数组有多大，只返回<strong>有效的索引</strong>。如果数组包含5个元素，散列函数就不会返回无效索引100。</li>
</ul>
<p>我们结合使用散列函数和数组创建了一种被称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{散列表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">散</span><span class="mord cjk_fallback" style="color:red;">列</span><span class="mord cjk_fallback" style="color:red;">表</span></span></span></span></span>（hash table）的数据结构。散列表是我们学习到的第一种<strong>包含额外逻辑</strong>的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。散列表也被称为散列映射、映射、字典和关联数组。</p>
<p>你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为<strong>字典</strong>，你可使用函数<code>dict</code>来创建散列表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建散列表</span></span><br><span class="line">book = dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加商品价格</span></span><br><span class="line">book[<span class="string">'apple'</span>] = <span class="number">0.67</span></span><br><span class="line">book[<span class="string">'milk'</span>] = <span class="number">1.49</span></span><br><span class="line">book[<span class="string">'avocado'</span>] = <span class="number">1.49</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询商品价格</span></span><br><span class="line">book[<span class="string">'avocado'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.49</span></span><br></pre></td></tr></table></figure>
<p>散列表由<strong>键</strong>和<strong>值</strong>组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键鳄梨的价格映射到值。</p>
<hr>
<h3 id="实际用途"><a class="markdownIt-Anchor" href="#实际用途"></a> 实际用途</h3>
<h4 id="1-网站解析"><a class="markdownIt-Anchor" href="#1-网站解析"></a> 1. 网站解析</h4>
<p>散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io这样的网站时，计算机必须将adit.io转换为IP地址。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808101158.png" alt></p>
<p>这种将网址映射到IP地址的过程被称为DNS解析（DNS resolution）。</p>
<hr>
<h4 id="2-避免重复"><a class="markdownIt-Anchor" href="#2-避免重复"></a> 2. 避免重复</h4>
<p>假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投<br>
票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。</p>
<p>如果名字在名单中，就说明这个人投过票了，因此将他拒之门外！否则，就将他的姓名加入到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808101406.png" alt></p>
<p>每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办法，那就是使用散列表！</p>
<p>首先创建一个散列表，由于记录已经投票的人：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>voted = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当有人来投票时，我们检查他是否在散列表中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>value = voted.get(<span class="string">"tom"</span>)</span><br></pre></td></tr></table></figure>
<p>如果“tom”在散列表中，函数get将返回它；否则返回None。你可使用这个函数检查来投票的人是否投过票！</p>
<p>整体代表如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">voted = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_voter</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> voted.get(name):	<span class="comment"># 如果查询到名字已经在名单上</span></span><br><span class="line">        print(<span class="string">"kick them out"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        voted[name] = <span class="literal">True</span></span><br><span class="line">        print(<span class="string">"let them vote!"</span>)</span><br></pre></td></tr></table></figure>
<p>散列表让我们能够迅速知道 来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。</p>
<hr>
<h4 id="3-将散列表用作缓存"><a class="markdownIt-Anchor" href="#3-将散列表用作缓存"></a> 3. 将散列表用作缓存</h4>
<p><a href="http://xn--facebook-or1m25ijy1ednxaes8bucny69a3qhva0408b.com" target="_blank" rel="noopener">假设我们正要访问网站facebook.com</a>：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808102138.png" alt></p>
<p>例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢！</p>
<p>另一方面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。 为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器少做些工作，从而提高Facebook网站的访问速度呢？</p>
<p>假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远？月球呢？木星呢？每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她<strong>老问你月球离地球多远</strong>，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她答案。这就是缓存的工作原理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">网</mi><mi mathvariant="normal">站</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">记</mi><mi mathvariant="normal">住</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">而</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">新</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{网站将数据记住，而不再重新计算}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">网</span><span class="mord cjk_fallback" style="color:orange;">站</span><span class="mord cjk_fallback" style="color:orange;">将</span><span class="mord cjk_fallback" style="color:orange;">数</span><span class="mord cjk_fallback" style="color:orange;">据</span><span class="mord cjk_fallback" style="color:orange;">记</span><span class="mord cjk_fallback" style="color:orange;">住</span><span class="mord cjk_fallback" style="color:orange;">，</span><span class="mord cjk_fallback" style="color:orange;">而</span><span class="mord cjk_fallback" style="color:orange;">不</span><span class="mord cjk_fallback" style="color:orange;">再</span><span class="mord cjk_fallback" style="color:orange;">重</span><span class="mord cjk_fallback" style="color:orange;">新</span><span class="mord cjk_fallback" style="color:orange;">计</span><span class="mord cjk_fallback" style="color:orange;">算</span></span></span></span></span>。</p>
<p>如果你登录了Facebook，你看到的所有内容都是为你定制的。<a href="http://xn--facebook-im2m350uxtbi29plx1a.com" target="_blank" rel="noopener">你每次访问facebook.com</a>，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到的<strong>登录页面都相同</strong>。Facebook被反复要求做同样的事情：“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">当</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">销</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">请</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">主</mi><mi mathvariant="normal">页</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{当我注销时，请向我显示主页}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">当</span><span class="mord cjk_fallback" style="color:orange;">我</span><span class="mord cjk_fallback" style="color:orange;">注</span><span class="mord cjk_fallback" style="color:orange;">销</span><span class="mord cjk_fallback" style="color:orange;">时</span><span class="mord cjk_fallback" style="color:orange;">，</span><span class="mord cjk_fallback" style="color:orange;">请</span><span class="mord cjk_fallback" style="color:orange;">向</span><span class="mord cjk_fallback" style="color:orange;">我</span><span class="mord cjk_fallback" style="color:orange;">显</span><span class="mord cjk_fallback" style="color:orange;">示</span><span class="mord cjk_fallback" style="color:orange;">主</span><span class="mord cjk_fallback" style="color:orange;">页</span></span></span></span></span>。”有鉴于此，它不让服务器去生成主页，而是<strong>将主页存储起来</strong>，并在需要时将其直接发送给用户。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808102456.png" alt></p>
<p>这就是缓存，具有如下两个优点:</p>
<ul>
<li>用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。</li>
<li>Facebook需要做的工作更少。</li>
</ul>
<p>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在<strong>散列表</strong>中！</p>
<p>Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">将</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">面</mi><mi>U</mi><mi>R</mi><mi>L</mi><mi mathvariant="normal">映</mi><mi mathvariant="normal">射</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{将页面URL映射到页面数据}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">将</span><span class="mord cjk_fallback" style="color:red;">页</span><span class="mord cjk_fallback" style="color:red;">面</span><span class="mord mathdefault" style="margin-right:0.10903em;color:red;">U</span><span class="mord mathdefault" style="margin-right:0.00773em;color:red;">R</span><span class="mord mathdefault" style="color:red;">L</span><span class="mord cjk_fallback" style="color:red;">映</span><span class="mord cjk_fallback" style="color:red;">射</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">页</span><span class="mord cjk_fallback" style="color:red;">面</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">据</span></span></span></span></span>。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808102639.png" alt></p>
<p>代码与存储商品价格类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cache = &#123;&#125; <span class="comment"># 定义缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cache.get(url):</span><br><span class="line">        <span class="keyword">return</span> cache[url]	<span class="comment"># 返回缓存数据</span></span><br><span class="line">   	<span class="keyword">else</span>:</span><br><span class="line">        data = get_data_from_server(url)	<span class="comment"># 从服务器中获取数据</span></span><br><span class="line">        cache[url] = data	<span class="comment"># 将数据保存到缓存中</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。</p>
<hr>
<h3 id="冲突"><a class="markdownIt-Anchor" href="#冲突"></a> 冲突</h3>
<p>知道散列表的用途后，我们自然会想到散列表的性能如何。然而，要明白散列表的性能，我们得先搞清楚什么是冲突。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808103206.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808103414.png" alt></p>
<p>可以发现，在第一个位置已经存储了苹果的价格，这种情况下，苹果和鳄梨争夺第一个位置，这就称为<strong>冲突</strong>(collision)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">给</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">同</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{给两个键分配的位置相同}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">给</span><span class="mord cjk_fallback" style="color:red;">两</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">分</span><span class="mord cjk_fallback" style="color:red;">配</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">位</span><span class="mord cjk_fallback" style="color:red;">置</span><span class="mord cjk_fallback" style="color:red;">相</span><span class="mord cjk_fallback" style="color:red;">同</span></span></span></span></span>。</p>
<p>如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格，以后再查询苹果的价格时，得到的将是鳄梨的价格！冲突很糟糕，必须要避免。处理冲突的方式很多，最简单的办法如下：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">映</mi><mi mathvariant="normal">射</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mo separator="true">,</mo><mi mathvariant="normal">就</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{如果两个键映射到了同一个位置,就在这个位置存储一个链表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3em;vertical-align:-0.19444em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">如</span><span class="mord cjk_fallback" style="color:orange;">果</span><span class="mord cjk_fallback" style="color:orange;">两</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">键</span><span class="mord cjk_fallback" style="color:orange;">映</span><span class="mord cjk_fallback" style="color:orange;">射</span><span class="mord cjk_fallback" style="color:orange;">到</span><span class="mord cjk_fallback" style="color:orange;">了</span><span class="mord cjk_fallback" style="color:orange;">同</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">位</span><span class="mord cjk_fallback" style="color:orange;">置</span><span class="mpunct" style="color:orange;">,</span><span class="mspace" style="color:orange;margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback" style="color:orange;">就</span><span class="mord cjk_fallback" style="color:orange;">在</span><span class="mord cjk_fallback" style="color:orange;">这</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">位</span><span class="mord cjk_fallback" style="color:orange;">置</span><span class="mord cjk_fallback" style="color:orange;">存</span><span class="mord cjk_fallback" style="color:orange;">储</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">链</span><span class="mord cjk_fallback" style="color:orange;">表</span></span></span></span></span>。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808103620.png" alt></p>
<p>这种情况下，除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟糕：散列表的速度会很慢。</p>
<p>这样就引出了使用散列表的一些经验：</p>
<ul>
<li><strong>散列函数很重要</strong>。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">匀</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">映</mi><mi mathvariant="normal">射</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{散列函数将键均匀地映射到散列表的不同位置}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">散</span><span class="mord cjk_fallback" style="color:red;">列</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">将</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">均</span><span class="mord cjk_fallback" style="color:red;">匀</span><span class="mord cjk_fallback" style="color:red;">地</span><span class="mord cjk_fallback" style="color:red;">映</span><span class="mord cjk_fallback" style="color:red;">射</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">散</span><span class="mord cjk_fallback" style="color:red;">列</span><span class="mord cjk_fallback" style="color:red;">表</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">位</span><span class="mord cjk_fallback" style="color:red;">置</span></span></span></span></span>。</li>
<li>如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，<strong>这些链表就不会很长</strong>！</li>
</ul>
<hr>
<h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3>
<h4 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h4>
<p>已知，一个好的散列函数很少会导致冲突，那么如果选择好的散列函数就是性能所要考虑的事情了。</p>
<p>本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。在平均情况下，散列表执行各种操作的时间都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>被称为<strong>常量时间</strong>。</p>
<blockquote>
<p>从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104039.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104110.png" alt></p>
<hr>
<p>我们将散列表和数组、链表进行对比：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104254.png" alt></p>
<p>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。 因此，在使用散列表时，避开最糟情况至关重要。</p>
<p>为此，需要避免冲突。而要避免冲突，需要有：</p>
<ul>
<li>较低的填装因子；</li>
<li>良好的散列函数</li>
</ul>
<hr>
<h4 id="填装因子"><a class="markdownIt-Anchor" href="#填装因子"></a> 填装因子</h4>
<p>散列表使用<strong>数组</strong>来存储数据，因此你需要计算数组中被占用的位置数。</p>
<p>散列表的填装因子计算公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">填</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">子</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">数</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">填装因子 = \frac{散列表包含的元素数}{位置总数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">填</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">子</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">散</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>以下图为例：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104708.png" alt></p>
<p>总共的位置数为5，其中被占用了2个位置，根据公式可知，填装因子为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2}{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p>
<p>填装因子度量的是散列表中有多少位置是空的。假设你要在散列表中存储100种商品的价格，而该散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。那么这个散列表填装因子就为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>100</mn><mn>100</mn></mfrac><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{100}{100}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>如果这个散列表只有50个位置呢？填充因子将为2。不可能让每种商品都有自己的位置，<strong>因为没有足够的位置</strong>！</p>
<p>填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">调</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{调整长度}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">调</span><span class="mord cjk_fallback" style="color:orange;">整</span><span class="mord cjk_fallback" style="color:orange;">长</span><span class="mord cjk_fallback" style="color:orange;">度</span></span></span></span></span>（resizing）。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808105116.png" alt></p>
<p>这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">旦</mi><mi mathvariant="normal">填</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mn>0.7</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{一旦填装因子大于0.7，就调整散列表的长度}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">旦</span><span class="mord cjk_fallback" style="color:orange;">填</span><span class="mord cjk_fallback" style="color:orange;">装</span><span class="mord cjk_fallback" style="color:orange;">因</span><span class="mord cjk_fallback" style="color:orange;">子</span><span class="mord cjk_fallback" style="color:orange;">大</span><span class="mord cjk_fallback" style="color:orange;">于</span><span class="mord" style="color:orange;">0</span><span class="mord" style="color:orange;">.</span><span class="mord" style="color:orange;">7</span><span class="mord cjk_fallback" style="color:orange;">，</span><span class="mord cjk_fallback" style="color:orange;">就</span><span class="mord cjk_fallback" style="color:orange;">调</span><span class="mord cjk_fallback" style="color:orange;">整</span><span class="mord cjk_fallback" style="color:orange;">散</span><span class="mord cjk_fallback" style="color:orange;">列</span><span class="mord cjk_fallback" style="color:orange;">表</span><span class="mord cjk_fallback" style="color:orange;">的</span><span class="mord cjk_fallback" style="color:orange;">长</span><span class="mord cjk_fallback" style="color:orange;">度</span></span></span></span></span>。</p>
<p>你可能在想，调整散列表长度的工作需要很长时间！你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。但<strong>平均而言</strong>，即便考虑到调整长度所需的时间，散列表操作所需的时间也为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<hr>
<h4 id="良好的散列函数"><a class="markdownIt-Anchor" href="#良好的散列函数"></a> 良好的散列函数</h4>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808105514.png" alt></p>
<p>散列函数的结果必须是<strong>均匀分布</strong>的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。</p>
<p>什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下<strong>SHA函数</strong>。你可将它用作散列函数。</p>
<hr>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。</p>
<ul>
<li>你可以结合散列函数和数组来创建散列表</li>
<li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数</li>
<li>平均情况下，散列表的查找、插入和删除速度都非常快</li>
<li>散列表适合用于<strong>模拟映射关系</strong></li>
<li>一旦填装因子超过<strong>0.7</strong>，就该调整散列表的长度</li>
<li>散列表可用于<strong>缓存</strong>数据（例如，在Web服务器上）</li>
<li>散列表非常适合用于防止重复</li>
</ul>
<hr>
<h3 id="补充sha算法"><a class="markdownIt-Anchor" href="#补充sha算法"></a> 🔐  补充——SHA算法</h3>
<h4 id="回顾"><a class="markdownIt-Anchor" href="#回顾"></a> 回顾</h4>
<p>假设你有一个键，需要将其相关联的值放到数组中:</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808110358.png" alt></p>
<p>这样查找时间是固定的。当你想要知道<strong>指定键对应的值</strong>时，可再次执行散列函数，它将告诉你这个值存储在什么地方，需要的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<hr>
<h4 id="比较文件"><a class="markdownIt-Anchor" href="#比较文件"></a> 比较文件</h4>
<p>另一种散列函数是<strong>安全散列算法</strong>（secure hash algorithm，SHA）函数。给定一个<strong>字符串</strong>，SHA返回其散列值。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808110741.png" alt></p>
<p>SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mi mathvariant="normal">根</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">另</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{SHA根据字符串生成另一个字符串}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord mathdefault" style="margin-right:0.05764em;color:orange;">S</span><span class="mord mathdefault" style="margin-right:0.08125em;color:orange;">H</span><span class="mord mathdefault" style="color:orange;">A</span><span class="mord cjk_fallback" style="color:orange;">根</span><span class="mord cjk_fallback" style="color:orange;">据</span><span class="mord cjk_fallback" style="color:orange;">字</span><span class="mord cjk_fallback" style="color:orange;">符</span><span class="mord cjk_fallback" style="color:orange;">串</span><span class="mord cjk_fallback" style="color:orange;">生</span><span class="mord cjk_fallback" style="color:orange;">成</span><span class="mord cjk_fallback" style="color:orange;">另</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">字</span><span class="mord cjk_fallback" style="color:orange;">符</span><span class="mord cjk_fallback" style="color:orange;">串</span></span></span></span></span>。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111244.png" alt></p>
<blockquote>
<p>SHA 生成的散列值很长，这里截短了。</p>
</blockquote>
<p>你可使用SHA来判断两个文件是否相同，这在<strong>比较超大型文件时很有用</strong>。假设你有一个4 GB的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送给朋友，而可计算它们的<strong>SHA散列值</strong>，再对结果进行比较。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111408.png" alt></p>
<hr>
<h4 id="检查密码"><a class="markdownIt-Anchor" href="#检查密码"></a> 检查密码</h4>
<p>SHA还让你能在不知道原始字符串的情况下对其进行比较。例如，假设Gmail遭到攻击，攻击者窃取了所有的密码！你的密码暴露了吗？没有，因为Google存储的并非密码，而是<strong>密码的SHA散列值</strong>！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111621.png" alt></p>
<p>Google只是比较散列值，因此不必存储你的密码！SHA被广泛用于<strong>计算密码的散列值</strong>。这种散列算法是<strong>单向</strong>的。你可根据字符串计算出散列值。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111937.png" alt></p>
<p>这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码转换为散列值，但反过来不行。</p>
<p>SHA实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。 当前，最安全的密码散列函数是<strong>bcrypt</strong>，但没有任何东西是万无一失的。</p>
<hr>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm" target="_blank" rel="noopener">khanacademy: The Euclidean Algorithm</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lucas Chan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bingobounce.github.io/2019/08/06/Algorithm-2/">https://bingobounce.github.io/2019/08/06/Algorithm-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm    </a><a class="post-meta__tags" href="/tags/图书/">图书    </a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d33fdf87eb6c9a7" async></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/07/note-2/"><img class="prev_cover lozad" data-src="/img/day2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>每日一记： 第2话</span></div></a></div><div class="next-post pull-right"><a href="/2019/08/05/note-1/"><img class="next_cover lozad" data-src="/img/day1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>每日一记： 第1话</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/08/02/Algorithm-1/" title="《算法图解》学习笔记：上部"><img class="relatedPosts_cover lozad" data-src="/img/algorithm.jpg"><div class="relatedPosts_title">《算法图解》学习笔记：上部</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'X5gVrHkkd6SlqAAJLsxK8cWw-gzGzoHsz',
  appKey:'8TlInhbKia6LM1d5ozLTBzCb',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Lucas Chan</div><div class="footer_custom_text">Hi, welcome to my <a href="https://bingobounce.github.io/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
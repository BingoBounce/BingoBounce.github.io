<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>《算法图解》学习笔记：中部 | Ain't A Thing</title><meta name="description" content="中部内容：快速排序"><meta name="keywords" content="Algorithm,图书"><meta name="author" content="Lucas Chan"><meta name="copyright" content="Lucas Chan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://bingobounce.github.io/2019/08/06/Algorithm-2/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="《算法图解》学习笔记：中部"><meta name="twitter:description" content="中部内容：快速排序"><meta name="twitter:image" content="https://bingobounce.github.io/img/algorithm.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《算法图解》学习笔记：中部"><meta property="og:url" content="https://bingobounce.github.io/2019/08/06/Algorithm-2/"><meta property="og:site_name" content="Ain't A Thing"><meta property="og:description" content="中部内容：快速排序"><meta property="og:image" content="https://bingobounce.github.io/img/algorithm.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="每日一记： 第1话" href="https://bingobounce.github.io/2019/08/05/note-1/"><meta name="google-site-verification" content="4Wddu4-AT6-v7UmSZOl4zCV1QKyMs9I5Bbf4GEfHptg"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-iv-快速排序"><span class="toc-number">1.</span> <span class="toc-text"> Chapter Ⅳ 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分而治之"><span class="toc-number">1.1.</span> <span class="toc-text"> 分而治之</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧几里得算法"><span class="toc-number">1.2.</span> <span class="toc-text"> 欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#another-example-数组元素和"><span class="toc-number">1.3.</span> <span class="toc-text"> Another example: 数组元素和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">1.4.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python实现"><span class="toc-number">1.5.</span> <span class="toc-text"> python实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再谈大o表示法"><span class="toc-number">1.6.</span> <span class="toc-text"> 再谈大O表示法</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/algorithm.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ain't A Thing</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> Message</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《算法图解》学习笔记：中部</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-08-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-08-06</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Algorithm/">Algorithm</a></span><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>Reading time: 6 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="chapter-iv-快速排序"><a class="markdownIt-Anchor" href="#chapter-iv-快速排序"></a> Chapter Ⅳ 快速排序</h2>
<p>本章主要探索<strong>分而治之</strong>（divide and conquer，D&amp;C）——一种著名的递归式问题解决方法。</p>
<h3 id="分而治之"><a class="markdownIt-Anchor" href="#分而治之"></a> 分而治之</h3>
<p>假设我们有一块土地，现在要将这块地<strong>均匀</strong>地分成<strong>方块</strong>，且分出的方块要尽可能大。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092349.png" alt></p>
<p>而下图中的分法都不太合适：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092446.png" alt></p>
<p>为了解决这个问题，我们可以使用D&amp;C策略。D&amp;C算法是递归的，其过程包括两个步骤：</p>
<ol>
<li>找出基线条件，这种条件必须尽可能简单。</li>
<li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li>
</ol>
<p>对于这个问题，我们先找出基线条件。因为要将土地均匀分为方块，最容易处理的情况是，一条边的长度是另一条边的整数倍：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092820.png" alt></p>
<p>对于一块长50米，宽25米的土地，我们可以将这样土地分为两块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>25</mn><mi>m</mi><mo>×</mo><mn>25</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">25m\times 25m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span></span></span></span>的方块。</p>
<p>现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须<br>
缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出<strong>这块地可容纳的最大方块</strong>。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806093136.png" alt></p>
<p>以大土地的宽度640m为边长，可以得到两个最大的方块，同时余下一小块地。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806093433.png" alt></p>
<p>我们将这两个最大方块可直接分为许多个大小均匀的方块。而对于剩下的土地，我们又可以使用相同的方法来划分，以此类推，就形成了一个递归问题。换言之，你将均匀划分$1680 m×640 m $土地的问题，简化成了均匀划分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>640</mn><mi>m</mi><mo>×</mo><mn>400</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">640 m×400 m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>土地的问题！</p>
<p>我们再以最大宽度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">400m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>为边长，对剩下土地划分，于是又剩下一块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn><mi>m</mi><mo>×</mo><mn>240</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">400m\times 240m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>的土地，以此递归：</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100107.png" alt></p>
<p>最终获得问题的答案!</p>
<hr>
<h3 id="欧几里得算法"><a class="markdownIt-Anchor" href="#欧几里得算法"></a> 欧几里得算法</h3>
<p>在&quot;分而治之&quot;小节中引入了一种思想： <em>适用于这小块地的最大方块，也是适用于整块地的最大方块</em>。这个思想的原理来自欧几里得算法(The Euclidean Algorithm).</p>
<p>欧几里德算法是一种快速查找两个整数的最大公因数the Greatest Common Divisor (GCD) 的技术。</p>
<p>算法的步骤如下：</p>
<ul>
<li>
<p>假设现在我们需要寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>,即A、B的最大公因数。</p>
<ul>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,这是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(0,B)=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,则我们可以终止算法.</p>
</li>
<li>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,这是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,0)=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,则我们可以终止算法.</p>
</li>
<li>
<p>写出A关于B的一个商余的式子(<strong>算术余子式</strong>)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mo separator="true">⋅</mo><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">A=B·Q+R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>.</p>
</li>
<li>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=\mathrm{GCD}(B,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>,则我们只需对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(B,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>使用欧几里得算法，即可找出A,B的gcd.</p>
</li>
</ul>
</li>
</ul>
<p>欧几里得算法利用性质:<strong>If A = B⋅Q + R and B≠0 then GCD(A,B) = GCD(B,R)</strong> ,迅速地将问题简化为越来越简单的问题，直到利用前两个性质中的一个很容易地解决为止。</p>
<p>而这个性质的证明可汗学院提供了一种非常直观的方式来解决<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806095603.png" alt></p>
<blockquote></blockquote>
<hr>
<h3 id="another-example-数组元素和"><a class="markdownIt-Anchor" href="#another-example-数组元素和"></a> Another example: 数组元素和</h3>
<p>给定一个数字数组：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，我们想使用递归函数来解决问题。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100512.png" alt></p>
<blockquote>
<p>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是<strong>空数组</strong>或只包含<strong>一个元素的数组</strong>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100610.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100711.png" alt></p>
<p>🔑 <strong>提示</strong>： 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时， 请检查基线条件是不是这样的。</p>
<hr>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806104747.png" alt></p>
<p>先使用数组第一个元素作为基准值，然后找出比基准值小的元素和比基准值大的元素。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806104944.png" alt></p>
<p>这个操作称为<strong>分区</strong>(partitioning).现在我们获得了：</p>
<ul>
<li>一个由所有小于基准值的数字组成的子数组；</li>
<li>一个由所有大于基准值的数组组成的子数组；</li>
<li>基准值</li>
</ul>
<p>在进行分区后，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105124.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105515.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105626.png" alt></p>
<p>理解快速排序大致过程后，我们可能会疑问<strong>基准值</strong>如何选取呢？</p>
<p>其实将任何元素用作基准值都可行:</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105825.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105836.png" alt></p>
<p>因此我们能够对包含五个元素的数组进行排序。同理，也能够对包含六个元素的数组进行排序，以此类推。</p>
<hr>
<h3 id="python实现"><a class="markdownIt-Anchor" href="#python实现"></a> python实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr <span class="comment"># 基线条件：数组为空或只包含一个元素的数组是“有序”的</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 递归过程</span></span><br><span class="line">        pivot = arr[<span class="number">0</span>] <span class="comment"># 选取数组第一个元素基准值</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot] <span class="comment"># 比基准值小的元素组成一个数组</span></span><br><span class="line">        greater [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot] <span class="comment"># 比基准值大的元素组成一个数组</span></span><br><span class="line">        <span class="comment"># 返回数组</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="再谈大o表示法"><a class="markdownIt-Anchor" href="#再谈大o表示法"></a> 再谈大O表示法</h3>
<p>快速排序的独特之处在于，其速度取决于选择的<strong>基准值</strong>。在讨论快速排序的运行时间前，我<br>
们再来看看最常见的大O运行时间。</p>
<p>假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112444.png" alt></p>
<p>注意，数组并没有被分成两半，相反，<strong>其中一个子数组始终为空，这导致调用栈非常长</strong>。现在假设你总是将<strong>中间的元素</strong>用作基准值，在这种情况下，调用栈如下。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112552.png" alt></p>
<p>现在来看看栈的第一层。你将一个元素用作基准值，并将其他的元素划分到两个子数组中。这涉及数组中的全部8个元素，因此该操作的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。在调用栈的第一层，涉及全部8个元素， 但实际上，在调用栈的每层都涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个元素。</p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112835.png" alt></p>
<p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806113023.png" alt></p>
<p>在这个示例中，层数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>（用技术术语说，<strong>调用栈的高度</strong>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>），而每层需要的<br>
时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。因此整个算法需要的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) * O(\log n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。这就是最佳情况。 在最糟情况下，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>层，因此该算法的运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) * O(n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>最佳情况其实也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。快速排序是最快的排序算法之一，也是D&amp;C典范。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm" target="_blank" rel="noopener">khanacademy: The Euclidean Algorithm</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lucas Chan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bingobounce.github.io/2019/08/06/Algorithm-2/">https://bingobounce.github.io/2019/08/06/Algorithm-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm    </a><a class="post-meta__tags" href="/tags/图书/">图书    </a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d33fdf87eb6c9a7" async></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/08/05/note-1/"><img class="next_cover lozad" data-src="/img/day1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>每日一记： 第1话</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/08/02/Algorithm-1/" title="《算法图解》学习笔记：上部"><img class="relatedPosts_cover lozad" data-src="/img/algorithm.jpg"><div class="relatedPosts_title">《算法图解》学习笔记：上部</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'X5gVrHkkd6SlqAAJLsxK8cWw-gzGzoHsz',
  appKey:'8TlInhbKia6LM1d5ozLTBzCb',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Lucas Chan</div><div class="footer_custom_text">Hi, welcome to my <a href="https://bingobounce.github.io/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="/js/search/local-search.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/08/08/note-3/"/>
      <url>/2019/08/08/note-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>封面： Photo by <a href="https://unsplash.com/@jontyson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Jon Tyson</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p></blockquote><h2 id="第3话-矢量图像"><a class="markdownIt-Anchor" href="#第3话-矢量图像"></a> 第3话： 矢量图像</h2><h3 id="第一幕-矢量图显示"><a class="markdownIt-Anchor" href="#第一幕-矢量图显示"></a> 第一幕 矢量图显示</h3><blockquote><p>下列操作将在jupyter notebook中进行。</p></blockquote><p>为生成矢量图，我们需要使用到IPython包中的display模块。先将所需模块导入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>通过设置matplotlib在display中显示属性，来显示矢量图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">display.set_matplotlib_formats(<span class="string">'svg'</span>)</span><br></pre></td></tr></table></figure><p>同时，也可以调整矢量图的尺寸：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">figsize=(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = figsize</span><br></pre></td></tr></table></figure><hr><h3 id="第二幕-显示图像而不打印对象信息"><a class="markdownIt-Anchor" href="#第二幕-显示图像而不打印对象信息"></a> 第二幕 显示图像而不打印对象信息</h3><p>一般地，当我们在<kbd>matplotlib</kbd>中方法绘制图像时，都会同时返回一个图像对象信息和图像。</p><p>假设代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, y, alpha=<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><p>得到如下图信息：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808162711.png" alt></p><p>如果我们不想显示红色划线部分信息，可以在绘图方法后加上<strong>分号：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, y, alpha=<span class="number">0.8</span>);<span class="comment"># # 加分号代表只显示图</span></span><br></pre></td></tr></table></figure><p>返回结果如下：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808163029.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 每日一记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一记： 第2话</title>
      <link href="/2019/08/07/note-2/"/>
      <url>/2019/08/07/note-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>封面： Photo by <a href="https://unsplash.com/@worldsbetweenlines?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Patrick Hendry</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p></blockquote><h2 id="第2话加速吧cython"><a class="markdownIt-Anchor" href="#第2话加速吧cython"></a> 第2话：加速吧，Cython！</h2><h3 id="第一幕-cython的优势"><a class="markdownIt-Anchor" href="#第一幕-cython的优势"></a> 第一幕 Cython的优势</h3><p>Cython 的本质可以总结如下：Cython 是包含 C 数据类型的 Python。几乎所有 Python 代码都是合法的 Cython 代码。 （存在一些限制，但是差不多也可以。） Cython 的编译器会转化 Python 代码为 C 代码，这些 C 代码均可以调用 Python/C 的 API。Cython 中的参数和变量还可以以 C 数据类型来声明。代码中的 Python 值和 C 的值可以自由地交叉混合（intermixed）使用, 所有的转化都是自动进行。并且全面支持 Python 的异常处理工具（facilities），包括 <code>try-except</code> 和 <code>try-finally</code>，即便在其中操作 C 数据都是可以的。</p><hr><h3 id="第二幕-入手cython"><a class="markdownIt-Anchor" href="#第二幕-入手cython"></a> 第二幕 入手Cython</h3><p>Cython可以接受几乎所有合法Python源文件，交叉混合使用Python/C。然而，C语言的编译非常重要，这也是开始的难点。</p><p>先从Hello World说起。创建一个<code>helloworld.pyx</code>文件，并写入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Hello world"</span>)</span><br></pre></td></tr></table></figure><p>然后创建一个<code>setup.py</code>文件，这是一个类似 Python Makefile 的文件，写入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ext_modules = cythonize(<span class="string">"helloworld.pyx"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>📓  Makefile文件关系到项目的<strong>编译规则</strong>，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p></blockquote><p>在命令行下构建我们的Cython文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><blockquote><p>运行完上述命令会在你的<strong>当前目录</strong>生成一个新文件，如果系统是 Unix，文件名为 <code>helloworld.so</code>，如果系统是 Windows，文件名为 <code>helloworld.pyd</code>。</p></blockquote><p>现在我们用一用刚生成的文件：打开 Python 的解释器(可以在命令行下敲入python开启解释器,前提已安装python环境)，像 import 普通文件一样直接 <code>import</code> 刚生成的文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> helloworld</span><br><span class="line"><span class="comment"># 返回 Hello World</span></span><br></pre></td></tr></table></figure><hr><h3 id="第三幕-cython的编译"><a class="markdownIt-Anchor" href="#第三幕-cython的编译"></a> 第三幕 Cython的编译</h3><p>如果我们模块不需要额外的 C 库特殊的构件安装，那你可以在 <code>import</code> 时使用 Paul Prescod 和 Stefan Behnel 编写的 <code>pyximport</code> 模块来直接读取 <code>.pyx</code> 文件，而不需要编写 <code>setup.py</code> 文件。 它随同 Cython 一并发布和安装，可以这样使用它：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是在ipython中</span></span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install()</span><br><span class="line"><span class="keyword">import</span> helloworld</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190807192331.png" alt></p><p>虽然<code>pyximport</code>模块支持了很多python模块的编译，但仍然有不少 Python 模块 Cython 无法编译。</p><p>这种情况下， import 机制（mechanism）会退回去读取 Python 原模块。<code>.py</code> 的 import 机制可按如下方式安装：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyximport.install(pyimport = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="第四幕-更多实例"><a class="markdownIt-Anchor" href="#第四幕-更多实例"></a> 第四幕 更多实例</h3><p>给出一个寻找质数的程序，我们告诉它你需要多少个质数，程序以 Python <code>list</code> 的形式将这些质数返回：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">(int kmax)</span>:</span></span><br><span class="line">    cdef int n, k, i</span><br><span class="line">    cdef int p[<span class="number">1000</span>]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> kmax &gt; <span class="number">1000</span>:</span><br><span class="line">        kmax = <span class="number">1000</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; kmax:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; k <span class="keyword">and</span> n % p[i] != <span class="number">0</span>:<span class="comment"># i,k,p[],n都是C对象</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == k:</span><br><span class="line">            p[k] = n</span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">            result.append(n)</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上述代码中，参数<code>kmax</code>是以int类型声明的。这意味着传入 <code>kmax</code> 的对象将会转化成 C 语言的整数变量。（如果无法转化为 <code>int</code> 型，将会抛出 <code>TypeError</code> 异常）。</p><p>第 2、3 行使用了 <code>cdef</code> 来定义 C 语言的局部变量。</p><p>第 11-12 行用候选数字除以已经找到的质数，这两行很有意思. 因为<strong>没有涉及 Python 对象</strong>，所以循环将会完全翻译为 C 语言代码，所以运行非常快！</p><p>第16行中，在 <code>twist</code> 的作用下 C 语言定义的变量 <code>n</code> 在 <code>append</code> 方法调用前会自动转化为 Python 对象。</p><p>使用 Cython 编译器编译 <code>primes.pyx</code> 文件来生成一个拓展模块，我们可以在ipthon中来试用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> primes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>primes.primes(<span class="number">10</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="第五幕-调用c函数"><a class="markdownIt-Anchor" href="#第五幕-调用c函数"></a> 第五幕 调用C函数</h3><p>先以一个 C 标准库中的函数为例。 我们不需要向你的代码中引入额外的依赖，Cython 都已经帮你定义好了这些函数。所以可以将这些函数直接 cimport 进来并使用。</p><p>比如说当我们想用最简单的方法将<code>char*</code>类型的值转化为一个整型值时， 可以使用<code>atoi()</code> 函数，这个函数是在<code>stdlib.h</code> 头文件中定义的。我们可以这样来写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdlib cimport atoi</span><br><span class="line"></span><br><span class="line">cdef parse_charptr_to_py_int(char* s):</span><br><span class="line">    <span class="keyword">assert</span> s <span class="keyword">is</span> <span class="keyword">not</span> NULL, <span class="string">"byte string value is NULL"</span></span><br><span class="line">    <span class="keyword">return</span> atoi(s)   <span class="comment"># note: atoi() has no error detection!</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可以在 Cython 的<a href="https://github.com/cython/cython/tree/master/Cython/Includes" target="_blank" rel="noopener">源代码包</a>中找到所有的标准 cimport 文件。</p></blockquote><hr><h2 id="灵感来源"><a class="markdownIt-Anchor" href="#灵感来源"></a> 灵感来源</h2><ol><li><a href="https://moonlet.gitbooks.io/cython-document-zh_cn/content/ch1-basic_tutorial.html" target="_blank" rel="noopener">Cython官方文档中文版</a></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/xiaonan153/article/details/81453560" target="_blank" rel="noopener">CSDN: makefile的作用是什么？</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 每日一记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》学习笔记：中部</title>
      <link href="/2019/08/06/Algorithm-2/"/>
      <url>/2019/08/06/Algorithm-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="chapter-iv-快速排序"><a class="markdownIt-Anchor" href="#chapter-iv-快速排序"></a> Chapter Ⅳ 快速排序</h2><p>本章主要探索<strong>分而治之</strong>（divide and conquer，D&amp;C）——一种著名的递归式问题解决方法。</p><h3 id="分而治之"><a class="markdownIt-Anchor" href="#分而治之"></a> 分而治之</h3><p>假设我们有一块土地，现在要将这块地<strong>均匀</strong>地分成<strong>方块</strong>，且分出的方块要尽可能大。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092349.png" alt></p><p>而下图中的分法都不太合适：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092446.png" alt></p><p>为了解决这个问题，我们可以使用D&amp;C策略。D&amp;C算法是递归的，其过程包括两个步骤：</p><ol><li>找出基线条件，这种条件必须尽可能简单。</li><li>不断将问题分解（或者说缩小规模），直到符合基线条件。</li></ol><p>对于这个问题，我们先找出基线条件。因为要将土地均匀分为方块，最容易处理的情况是，一条边的长度是另一条边的整数倍：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806092820.png" alt></p><p>对于一块长50米，宽25米的土地，我们可以将这样土地分为两块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>25</mn><mi>m</mi><mo>×</mo><mn>25</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">25m\times 25m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault">m</span></span></span></span>的方块。</p><p>现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须<br>缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出<strong>这块地可容纳的最大方块</strong>。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806093136.png" alt></p><p>以大土地的宽度640m为边长，可以得到两个最大的方块，同时余下一小块地。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806093433.png" alt></p><p>我们将这两个最大方块可直接分为许多个大小均匀的方块。而对于剩下的土地，我们又可以使用相同的方法来划分，以此类推，就形成了一个递归问题。换言之，你将均匀划分$1680 m×640 m $土地的问题，简化成了均匀划分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>640</mn><mi>m</mi><mo>×</mo><mn>400</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">640 m×400 m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>土地的问题！</p><p>我们再以最大宽度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">400m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>为边长，对剩下土地划分，于是又剩下一块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>400</mn><mi>m</mi><mo>×</mo><mn>240</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">400m\times 240m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span></span></span></span>的土地，以此递归：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100107.png" alt></p><p>最终获得问题的答案!</p><hr><h3 id="欧几里得算法"><a class="markdownIt-Anchor" href="#欧几里得算法"></a> 欧几里得算法</h3><p>在&quot;分而治之&quot;小节中引入了一种思想： <em>适用于这小块地的最大方块，也是适用于整块地的最大方块</em>。这个思想的原理来自欧几里得算法(The Euclidean Algorithm).</p><p>欧几里德算法是一种快速查找两个整数的最大公因数the Greatest Common Divisor (GCD) 的技术。</p><p>算法的步骤如下：</p><ul><li><p>假设现在我们需要寻找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>,即A、B的最大公因数。</p><ul><li><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,这是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(0,B)=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,则我们可以终止算法.</p></li><li><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,这是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,0)=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>,则我们可以终止算法.</p></li><li><p>写出A关于B的一个商余的式子(<strong>算术余子式</strong>)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mo separator="true">⋅</mo><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">A=B·Q+R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>.</p></li><li><p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(A,B)=\mathrm{GCD}(B,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>,则我们只需对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">D</mi></mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{GCD}(B,R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">G</span><span class="mord mathrm">C</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>使用欧几里得算法，即可找出A,B的gcd.</p></li></ul></li></ul><p>欧几里得算法利用性质:<strong>If A = B⋅Q + R and B≠0 then GCD(A,B) = GCD(B,R)</strong> ,迅速地将问题简化为越来越简单的问题，直到利用前两个性质中的一个很容易地解决为止。</p><p>而这个性质的证明可汗学院提供了一种非常直观的方式来解决<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806095603.png" alt></p><blockquote></blockquote><hr><h3 id="another-example-数组元素和"><a class="markdownIt-Anchor" href="#another-example-数组元素和"></a> Another example: 数组元素和</h3><p>给定一个数字数组：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,4,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，我们想使用递归函数来解决问题。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100512.png" alt></p><blockquote><p>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是<strong>空数组</strong>或只包含<strong>一个元素的数组</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100610.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806100711.png" alt></p><p>🔑 <strong>提示</strong>： 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时， 请检查基线条件是不是这样的。</p><hr><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806104747.png" alt></p><p>先使用数组第一个元素作为基准值，然后找出比基准值小的元素和比基准值大的元素。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806104944.png" alt></p><p>这个操作称为<strong>分区</strong>(partitioning).现在我们获得了：</p><ul><li>一个由所有小于基准值的数字组成的子数组；</li><li>一个由所有大于基准值的数组组成的子数组；</li><li>基准值</li></ul><p>在进行分区后，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105124.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105515.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105626.png" alt></p><p>理解快速排序大致过程后，我们可能会疑问<strong>基准值</strong>如何选取呢？</p><p>其实将任何元素用作基准值都可行:</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105825.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806105836.png" alt></p><p>因此我们能够对包含五个元素的数组进行排序。同理，也能够对包含六个元素的数组进行排序，以此类推。</p><hr><h3 id="python实现"><a class="markdownIt-Anchor" href="#python实现"></a> python实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr <span class="comment"># 基线条件：数组为空或只包含一个元素的数组是“有序”的</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 递归过程</span></span><br><span class="line">        pivot = arr[<span class="number">0</span>] <span class="comment"># 选取数组第一个元素基准值</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot] <span class="comment"># 比基准值小的元素组成一个数组</span></span><br><span class="line">        greater [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot] <span class="comment"># 比基准值大的元素组成一个数组</span></span><br><span class="line">        <span class="comment"># 返回数组</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br></pre></td></tr></table></figure><hr><h3 id="再谈大o表示法"><a class="markdownIt-Anchor" href="#再谈大o表示法"></a> 再谈大O表示法</h3><p>快速排序的独特之处在于，其速度取决于选择的<strong>基准值</strong>。在讨论快速排序的运行时间前，我<br>们再来看看最常见的大O运行时间。</p><p>假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112444.png" alt></p><p>注意，数组并没有被分成两半，相反，<strong>其中一个子数组始终为空，这导致调用栈非常长</strong>。现在假设你总是将<strong>中间的元素</strong>用作基准值，在这种情况下，调用栈如下。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112552.png" alt></p><p>现在来看看栈的第一层。你将一个元素用作基准值，并将其他的元素划分到两个子数组中。这涉及数组中的全部8个元素，因此该操作的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。在调用栈的第一层，涉及全部8个元素， 但实际上，在调用栈的每层都涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个元素。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806112835.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190806113023.png" alt></p><p>在这个示例中，层数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>（用技术术语说，<strong>调用栈的高度</strong>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>），而每层需要的<br>时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。因此整个算法需要的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) * O(\log n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。这就是最佳情况。 在最糟情况下，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>层，因此该算法的运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) * O(n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>最佳情况其实也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。快速排序是最快的排序算法之一，也是D&amp;C典范。</p><hr><h2 id="chapter-v-散列表"><a class="markdownIt-Anchor" href="#chapter-v-散列表"></a> Chapter Ⅴ 散列表</h2><h3 id="散列表的引入"><a class="markdownIt-Anchor" href="#散列表的引入"></a> 散列表的引入</h3><p>假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。</p><p>如果本子中内容没有按字母顺序排列，那么我们可能就要一行行查找了，这样的时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>了。如果本子内容是按照字母顺序排列的，那么可以使用二分查找来寻找，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><p>但是，如果我们能够记住所有商品价格，这样就不需要查找了，一个商品对应一个价格，即问即答，这样我们报出任何商品的价格的时间都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><p>为了存储商品及其价格，我们可以使用前面学习到的数据结构——数组。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808095544.png" alt></p><p>数组的每个元素包含两项内容：商品名和价格。如果将这个数组按商品名排序，就可使用二分查找在其中查找商品的价格。这样查找价格的时间将为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。然而，我们更加希望查找商品价格的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，那么散列函数就有用武之地了。</p><hr><h3 id="散列函数"><a class="markdownIt-Anchor" href="#散列函数"></a> 散列函数</h3><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808095718.png" alt></p><p>然后，散列数列输入和输出之间必须满足一些要求：</p><ul><li>它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。</li><li>它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</li></ul><p>下面就展示散列函数的魅力：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808100123.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808100243.png" alt></p><p>散列函数准确地指出了价格的存储位置，我们根本不用查找！而散列函数原理如下：</p><ul><li>散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。</li><li>散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。</li><li>散列函数知道数组有多大，只返回<strong>有效的索引</strong>。如果数组包含5个元素，散列函数就不会返回无效索引100。</li></ul><p>我们结合使用散列函数和数组创建了一种被称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{散列表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">散</span><span class="mord cjk_fallback" style="color:red;">列</span><span class="mord cjk_fallback" style="color:red;">表</span></span></span></span></span>（hash table）的数据结构。散列表是我们学习到的第一种<strong>包含额外逻辑</strong>的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。散列表也被称为散列映射、映射、字典和关联数组。</p><p>你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为<strong>字典</strong>，你可使用函数<code>dict</code>来创建散列表:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建散列表</span></span><br><span class="line">book = dict()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加商品价格</span></span><br><span class="line">book[<span class="string">'apple'</span>] = <span class="number">0.67</span></span><br><span class="line">book[<span class="string">'milk'</span>] = <span class="number">1.49</span></span><br><span class="line">book[<span class="string">'avocado'</span>] = <span class="number">1.49</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询商品价格</span></span><br><span class="line">book[<span class="string">'avocado'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.49</span></span><br></pre></td></tr></table></figure><p>散列表由<strong>键</strong>和<strong>值</strong>组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键鳄梨的价格映射到值。</p><hr><h3 id="实际用途"><a class="markdownIt-Anchor" href="#实际用途"></a> 实际用途</h3><h4 id="1-网站解析"><a class="markdownIt-Anchor" href="#1-网站解析"></a> 1. 网站解析</h4><p>散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io这样的网站时，计算机必须将adit.io转换为IP地址。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808101158.png" alt></p><p>这种将网址映射到IP地址的过程被称为DNS解析（DNS resolution）。</p><hr><h4 id="2-避免重复"><a class="markdownIt-Anchor" href="#2-避免重复"></a> 2. 避免重复</h4><p>假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投<br>票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。</p><p>如果名字在名单中，就说明这个人投过票了，因此将他拒之门外！否则，就将他的姓名加入到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808101406.png" alt></p><p>每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办法，那就是使用散列表！</p><p>首先创建一个散列表，由于记录已经投票的人：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>voted = &#123;&#125;</span><br></pre></td></tr></table></figure><p>当有人来投票时，我们检查他是否在散列表中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>value = voted.get(<span class="string">"tom"</span>)</span><br></pre></td></tr></table></figure><p>如果“tom”在散列表中，函数get将返回它；否则返回None。你可使用这个函数检查来投票的人是否投过票！</p><p>整体代表如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">voted = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_voter</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> voted.get(name):<span class="comment"># 如果查询到名字已经在名单上</span></span><br><span class="line">        print(<span class="string">"kick them out"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        voted[name] = <span class="literal">True</span></span><br><span class="line">        print(<span class="string">"let them vote!"</span>)</span><br></pre></td></tr></table></figure><p>散列表让我们能够迅速知道 来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。</p><hr><h4 id="3-将散列表用作缓存"><a class="markdownIt-Anchor" href="#3-将散列表用作缓存"></a> 3. 将散列表用作缓存</h4><p><a href="http://xn--facebook-or1m25ijy1ednxaes8bucny69a3qhva0408b.com" target="_blank" rel="noopener">假设我们正要访问网站facebook.com</a>：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808102138.png" alt></p><p>例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢！</p><p>另一方面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。 为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器少做些工作，从而提高Facebook网站的访问速度呢？</p><p>假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远？月球呢？木星呢？每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她<strong>老问你月球离地球多远</strong>，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她答案。这就是缓存的工作原理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">网</mi><mi mathvariant="normal">站</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">记</mi><mi mathvariant="normal">住</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">而</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">再</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">新</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{网站将数据记住，而不再重新计算}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">网</span><span class="mord cjk_fallback" style="color:orange;">站</span><span class="mord cjk_fallback" style="color:orange;">将</span><span class="mord cjk_fallback" style="color:orange;">数</span><span class="mord cjk_fallback" style="color:orange;">据</span><span class="mord cjk_fallback" style="color:orange;">记</span><span class="mord cjk_fallback" style="color:orange;">住</span><span class="mord cjk_fallback" style="color:orange;">，</span><span class="mord cjk_fallback" style="color:orange;">而</span><span class="mord cjk_fallback" style="color:orange;">不</span><span class="mord cjk_fallback" style="color:orange;">再</span><span class="mord cjk_fallback" style="color:orange;">重</span><span class="mord cjk_fallback" style="color:orange;">新</span><span class="mord cjk_fallback" style="color:orange;">计</span><span class="mord cjk_fallback" style="color:orange;">算</span></span></span></span></span>。</p><p>如果你登录了Facebook，你看到的所有内容都是为你定制的。<a href="http://xn--facebook-im2m350uxtbi29plx1a.com" target="_blank" rel="noopener">你每次访问facebook.com</a>，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到的<strong>登录页面都相同</strong>。Facebook被反复要求做同样的事情：“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">当</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">销</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">请</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">主</mi><mi mathvariant="normal">页</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{当我注销时，请向我显示主页}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">当</span><span class="mord cjk_fallback" style="color:orange;">我</span><span class="mord cjk_fallback" style="color:orange;">注</span><span class="mord cjk_fallback" style="color:orange;">销</span><span class="mord cjk_fallback" style="color:orange;">时</span><span class="mord cjk_fallback" style="color:orange;">，</span><span class="mord cjk_fallback" style="color:orange;">请</span><span class="mord cjk_fallback" style="color:orange;">向</span><span class="mord cjk_fallback" style="color:orange;">我</span><span class="mord cjk_fallback" style="color:orange;">显</span><span class="mord cjk_fallback" style="color:orange;">示</span><span class="mord cjk_fallback" style="color:orange;">主</span><span class="mord cjk_fallback" style="color:orange;">页</span></span></span></span></span>。”有鉴于此，它不让服务器去生成主页，而是<strong>将主页存储起来</strong>，并在需要时将其直接发送给用户。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808102456.png" alt></p><p>这就是缓存，具有如下两个优点:</p><ul><li>用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。</li><li>Facebook需要做的工作更少。</li></ul><p>缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在<strong>散列表</strong>中！</p><p>Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">将</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">面</mi><mi>U</mi><mi>R</mi><mi>L</mi><mi mathvariant="normal">映</mi><mi mathvariant="normal">射</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{将页面URL映射到页面数据}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">将</span><span class="mord cjk_fallback" style="color:red;">页</span><span class="mord cjk_fallback" style="color:red;">面</span><span class="mord mathdefault" style="margin-right:0.10903em;color:red;">U</span><span class="mord mathdefault" style="margin-right:0.00773em;color:red;">R</span><span class="mord mathdefault" style="color:red;">L</span><span class="mord cjk_fallback" style="color:red;">映</span><span class="mord cjk_fallback" style="color:red;">射</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">页</span><span class="mord cjk_fallback" style="color:red;">面</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">据</span></span></span></span></span>。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808102639.png" alt></p><p>代码与存储商品价格类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cache = &#123;&#125; <span class="comment"># 定义缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cache.get(url):</span><br><span class="line">        <span class="keyword">return</span> cache[url]<span class="comment"># 返回缓存数据</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">        data = get_data_from_server(url)<span class="comment"># 从服务器中获取数据</span></span><br><span class="line">        cache[url] = data<span class="comment"># 将数据保存到缓存中</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。</p><hr><h3 id="冲突"><a class="markdownIt-Anchor" href="#冲突"></a> 冲突</h3><p>知道散列表的用途后，我们自然会想到散列表的性能如何。然而，要明白散列表的性能，我们得先搞清楚什么是冲突。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808103206.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808103414.png" alt></p><p>可以发现，在第一个位置已经存储了苹果的价格，这种情况下，苹果和鳄梨争夺第一个位置，这就称为<strong>冲突</strong>(collision)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">给</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">配</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">同</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{给两个键分配的位置相同}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">给</span><span class="mord cjk_fallback" style="color:red;">两</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">分</span><span class="mord cjk_fallback" style="color:red;">配</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">位</span><span class="mord cjk_fallback" style="color:red;">置</span><span class="mord cjk_fallback" style="color:red;">相</span><span class="mord cjk_fallback" style="color:red;">同</span></span></span></span></span>。</p><p>如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格，以后再查询苹果的价格时，得到的将是鳄梨的价格！冲突很糟糕，必须要避免。处理冲突的方式很多，最简单的办法如下：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">映</mi><mi mathvariant="normal">射</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mo separator="true">,</mo><mi mathvariant="normal">就</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{如果两个键映射到了同一个位置,就在这个位置存储一个链表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3em;vertical-align:-0.19444em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">如</span><span class="mord cjk_fallback" style="color:orange;">果</span><span class="mord cjk_fallback" style="color:orange;">两</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">键</span><span class="mord cjk_fallback" style="color:orange;">映</span><span class="mord cjk_fallback" style="color:orange;">射</span><span class="mord cjk_fallback" style="color:orange;">到</span><span class="mord cjk_fallback" style="color:orange;">了</span><span class="mord cjk_fallback" style="color:orange;">同</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">位</span><span class="mord cjk_fallback" style="color:orange;">置</span><span class="mpunct" style="color:orange;">,</span><span class="mspace" style="color:orange;margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback" style="color:orange;">就</span><span class="mord cjk_fallback" style="color:orange;">在</span><span class="mord cjk_fallback" style="color:orange;">这</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">位</span><span class="mord cjk_fallback" style="color:orange;">置</span><span class="mord cjk_fallback" style="color:orange;">存</span><span class="mord cjk_fallback" style="color:orange;">储</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">链</span><span class="mord cjk_fallback" style="color:orange;">表</span></span></span></span></span>。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808103620.png" alt></p><p>这种情况下，除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟糕：散列表的速度会很慢。</p><p>这样就引出了使用散列表的一些经验：</p><ul><li><strong>散列函数很重要</strong>。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">键</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">匀</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">映</mi><mi mathvariant="normal">射</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{散列函数将键均匀地映射到散列表的不同位置}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">散</span><span class="mord cjk_fallback" style="color:red;">列</span><span class="mord cjk_fallback" style="color:red;">函</span><span class="mord cjk_fallback" style="color:red;">数</span><span class="mord cjk_fallback" style="color:red;">将</span><span class="mord cjk_fallback" style="color:red;">键</span><span class="mord cjk_fallback" style="color:red;">均</span><span class="mord cjk_fallback" style="color:red;">匀</span><span class="mord cjk_fallback" style="color:red;">地</span><span class="mord cjk_fallback" style="color:red;">映</span><span class="mord cjk_fallback" style="color:red;">射</span><span class="mord cjk_fallback" style="color:red;">到</span><span class="mord cjk_fallback" style="color:red;">散</span><span class="mord cjk_fallback" style="color:red;">列</span><span class="mord cjk_fallback" style="color:red;">表</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">位</span><span class="mord cjk_fallback" style="color:red;">置</span></span></span></span></span>。</li><li>如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，<strong>这些链表就不会很长</strong>！</li></ul><hr><h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3><h4 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h4><p>已知，一个好的散列函数很少会导致冲突，那么如果选择好的散列函数就是性能所要考虑的事情了。</p><p>本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。在平均情况下，散列表执行各种操作的时间都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>被称为<strong>常量时间</strong>。</p><blockquote><p>从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104039.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104110.png" alt></p><hr><p>我们将散列表和数组、链表进行对比：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104254.png" alt></p><p>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。 因此，在使用散列表时，避开最糟情况至关重要。</p><p>为此，需要避免冲突。而要避免冲突，需要有：</p><ul><li>较低的填装因子；</li><li>良好的散列函数</li></ul><hr><h4 id="填装因子"><a class="markdownIt-Anchor" href="#填装因子"></a> 填装因子</h4><p>散列表使用<strong>数组</strong>来存储数据，因此你需要计算数组中被占用的位置数。</p><p>散列表的填装因子计算公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">填</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">子</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">位</mi><mi mathvariant="normal">置</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">数</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">填装因子 = \frac{散列表包含的元素数}{位置总数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">填</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">子</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.363em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">散</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>以下图为例：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808104708.png" alt></p><p>总共的位置数为5，其中被占用了2个位置，根据公式可知，填装因子为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2}{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p>填装因子度量的是散列表中有多少位置是空的。假设你要在散列表中存储100种商品的价格，而该散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。那么这个散列表填装因子就为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>100</mn><mn>100</mn></mfrac><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{100}{100}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p><p>如果这个散列表只有50个位置呢？填充因子将为2。不可能让每种商品都有自己的位置，<strong>因为没有足够的位置</strong>！</p><p>填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">调</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{调整长度}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">调</span><span class="mord cjk_fallback" style="color:orange;">整</span><span class="mord cjk_fallback" style="color:orange;">长</span><span class="mord cjk_fallback" style="color:orange;">度</span></span></span></span></span>（resizing）。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808105116.png" alt></p><p>这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">旦</mi><mi mathvariant="normal">填</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mn>0.7</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">散</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{一旦填装因子大于0.7，就调整散列表的长度}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">旦</span><span class="mord cjk_fallback" style="color:orange;">填</span><span class="mord cjk_fallback" style="color:orange;">装</span><span class="mord cjk_fallback" style="color:orange;">因</span><span class="mord cjk_fallback" style="color:orange;">子</span><span class="mord cjk_fallback" style="color:orange;">大</span><span class="mord cjk_fallback" style="color:orange;">于</span><span class="mord" style="color:orange;">0</span><span class="mord" style="color:orange;">.</span><span class="mord" style="color:orange;">7</span><span class="mord cjk_fallback" style="color:orange;">，</span><span class="mord cjk_fallback" style="color:orange;">就</span><span class="mord cjk_fallback" style="color:orange;">调</span><span class="mord cjk_fallback" style="color:orange;">整</span><span class="mord cjk_fallback" style="color:orange;">散</span><span class="mord cjk_fallback" style="color:orange;">列</span><span class="mord cjk_fallback" style="color:orange;">表</span><span class="mord cjk_fallback" style="color:orange;">的</span><span class="mord cjk_fallback" style="color:orange;">长</span><span class="mord cjk_fallback" style="color:orange;">度</span></span></span></span></span>。</p><p>你可能在想，调整散列表长度的工作需要很长时间！你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。但<strong>平均而言</strong>，即便考虑到调整长度所需的时间，散列表操作所需的时间也为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><hr><h4 id="良好的散列函数"><a class="markdownIt-Anchor" href="#良好的散列函数"></a> 良好的散列函数</h4><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808105514.png" alt></p><p>散列函数的结果必须是<strong>均匀分布</strong>的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。</p><p>什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下<strong>SHA函数</strong>。你可将它用作散列函数。</p><hr><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。</p><ul><li>你可以结合散列函数和数组来创建散列表</li><li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数</li><li>平均情况下，散列表的查找、插入和删除速度都非常快</li><li>散列表适合用于<strong>模拟映射关系</strong></li><li>一旦填装因子超过<strong>0.7</strong>，就该调整散列表的长度</li><li>散列表可用于<strong>缓存</strong>数据（例如，在Web服务器上）</li><li>散列表非常适合用于防止重复</li></ul><hr><h3 id="补充sha算法"><a class="markdownIt-Anchor" href="#补充sha算法"></a> 🔐  补充——SHA算法</h3><h4 id="回顾"><a class="markdownIt-Anchor" href="#回顾"></a> 回顾</h4><p>假设你有一个键，需要将其相关联的值放到数组中:</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808110358.png" alt></p><p>这样查找时间是固定的。当你想要知道<strong>指定键对应的值</strong>时，可再次执行散列函数，它将告诉你这个值存储在什么地方，需要的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><hr><h4 id="比较文件"><a class="markdownIt-Anchor" href="#比较文件"></a> 比较文件</h4><p>另一种散列函数是<strong>安全散列算法</strong>（secure hash algorithm，SHA）函数。给定一个<strong>字符串</strong>，SHA返回其散列值。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808110741.png" alt></p><p>SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi>S</mi><mi>H</mi><mi>A</mi><mi mathvariant="normal">根</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">生</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">另</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{SHA根据字符串生成另一个字符串}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord mathdefault" style="margin-right:0.05764em;color:orange;">S</span><span class="mord mathdefault" style="margin-right:0.08125em;color:orange;">H</span><span class="mord mathdefault" style="color:orange;">A</span><span class="mord cjk_fallback" style="color:orange;">根</span><span class="mord cjk_fallback" style="color:orange;">据</span><span class="mord cjk_fallback" style="color:orange;">字</span><span class="mord cjk_fallback" style="color:orange;">符</span><span class="mord cjk_fallback" style="color:orange;">串</span><span class="mord cjk_fallback" style="color:orange;">生</span><span class="mord cjk_fallback" style="color:orange;">成</span><span class="mord cjk_fallback" style="color:orange;">另</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">字</span><span class="mord cjk_fallback" style="color:orange;">符</span><span class="mord cjk_fallback" style="color:orange;">串</span></span></span></span></span>。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111244.png" alt></p><blockquote><p>SHA 生成的散列值很长，这里截短了。</p></blockquote><p>你可使用SHA来判断两个文件是否相同，这在<strong>比较超大型文件时很有用</strong>。假设你有一个4 GB的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送给朋友，而可计算它们的<strong>SHA散列值</strong>，再对结果进行比较。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111408.png" alt></p><hr><h4 id="检查密码"><a class="markdownIt-Anchor" href="#检查密码"></a> 检查密码</h4><p>SHA还让你能在不知道原始字符串的情况下对其进行比较。例如，假设Gmail遭到攻击，攻击者窃取了所有的密码！你的密码暴露了吗？没有，因为Google存储的并非密码，而是<strong>密码的SHA散列值</strong>！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111621.png" alt></p><p>Google只是比较散列值，因此不必存储你的密码！SHA被广泛用于<strong>计算密码的散列值</strong>。这种散列算法是<strong>单向</strong>的。你可根据字符串计算出散列值。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190808111937.png" alt></p><p>这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码转换为散列值，但反过来不行。</p><p>SHA实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。 当前，最安全的密码散列函数是<strong>bcrypt</strong>，但没有任何东西是万无一失的。</p><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm" target="_blank" rel="noopener">khanacademy: The Euclidean Algorithm</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 图书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一记： 第1话</title>
      <link href="/2019/08/05/note-1/"/>
      <url>/2019/08/05/note-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>封面：Photo by <a href="https://unsplash.com/@wildhoney?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">John Fowler</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p></blockquote><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2><p>由于平时上课时间比较长，plus数学证明的摧残≡(▔﹏▔)≡，只能使用一些碎片时间来学习编程了，但还是会不定时出一些系统性学习的博客。</p><p>秉承着每天都积累一些新知识的初心，希望自己能够坚持下去，fighting!</p><h2 id="第1话参数管家rcparams登场"><a class="markdownIt-Anchor" href="#第1话参数管家rcparams登场"></a> 第1话：参数管家——rcParams登场</h2><h3 id="第一幕-样式表的祭献"><a class="markdownIt-Anchor" href="#第一幕-样式表的祭献"></a> 第一幕: 样式表的祭献</h3><p>我们可以使用一种创建自定义样式的方式: <strong>通过向<code>style.use</code>方法传入样式表的路径或者URL链接</strong>。</p><p>另外，可以创建一个<code>mpl_configdir/stylelib</code>目录，并且将样式内容写入<code>&lt;style-name&gt;.mplstyle</code>文件中，我们就可以直接通过使用<code>style.use(&lt;style-name&gt;)</code>的方式来复用自定义的样式表。</p><p><code>mpl_configdir</code>目录默认情况下， 应该创建在系统的<code>matplotlib</code>配置目录下，可以通过<kbd>matplotlib.get_configdir()</kbd>方法来获取目录路径。</p><p>在代码中，如果默认样式与<code>&lt;style-name&gt;.mplstyle</code>文件中自定义样式具有相同的名称，<code>mpl_configdir/stylelib</code>中的自定义样式表将覆盖由matplotlib定义的样式表。</p><p>⚙️ <code>&lt;style-name&gt;.mplstyle</code>文件每一行设置一个自定义参数。假设我们创建了<code>background.mplstyle</code>文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axes.titlesize : 24</span><br><span class="line">axes.labelsize : 20</span><br><span class="line">lines.linewidth : </span><br><span class="line">lines.markersize : 10</span><br></pre></td></tr></table></figure><p>并且在代码中调用设置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use([<span class="string">'background'</span>]) <span class="comment"># 可以传递多个.mplstyle文件</span></span><br></pre></td></tr></table></figure><hr><h3 id="第二幕"><a class="markdownIt-Anchor" href="#第二幕"></a> 第二幕</h3><p>如果只想为特定的代码块使用自定义样式，不希望更改全局样式，则<code>plt.style</code>包为我们提供了一个上下文管理器，用于将更改限制在特定的范围内。要隔离样式更改，可以编写如下内容:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> <span class="keyword">with</span> plt.style.context((<span class="string">'background'</span>)):</span><br><span class="line">        plt.plot(...)<span class="comment"># 自定义样式绘图</span></span><br></pre></td></tr></table></figure><hr><h3 id="第三幕rcparams登场"><a class="markdownIt-Anchor" href="#第三幕rcparams登场"></a> 第三幕：rcParams登场</h3><p>使用样式表自定义修改样式是一种静态方法，而设置<code>rcParams</code>可以动态地修改matplotlib全局样式。</p><p><code>rcParams</code>是Matplotlib中具有自定义参数的全局类字典变量。Matplotlib的几乎每个方面参数都可以在这里配置，例如在同一图形上显示多个绘图时，每个绘图通过一组预定义的颜色进行颜色循环：<kbd>rcParams[‘axes.color_cycle’] = [‘r’, ‘k’, ‘c’]</kbd>。所有rc设置都存储在名为matplotlib的类字典变量中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'lines.color'</span>] = <span class="string">'r'</span><span class="comment"># 设置曲线颜色为红色</span></span><br><span class="line">mpl.rcParams[<span class="string">'lines.linewidth'</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>还可以使用<kbd>matplotlib.rc()</kbd>命令一次修改一个组中的<strong>多个</strong>设置，使用关键字参数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rc(<span class="string">'lines'</span>, linewidth=<span class="number">2</span>, color=<span class="string">'r'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>使用<kbd>matplotlib.rcdefaults()</kbd>方法将会回复matplotlib默认设置。</p></blockquote><p>此外，还可以通过将它们保存在名为<code>matplotlibrc</code>的ASCII文本文件中来指定<strong>永久自定义</strong>选项，该文件可以存储在当前目录(用于本地选项)或<code>~/.matplotlib</code>中(用于全局选项)。</p><p>Matplotlib使用<code>matplotlibrc</code>配置文件定制各种属性，我们称之为<kbd>rc settings</kbd>或<kbd>rc parameters</kbd>。我们可以通过该文件控制matplotlib中几乎所有属性的默认值:图形大小和dpi、行宽、颜色和样式、轴、轴和网格属性、文本和字体属性等等。</p><p>在这个文件中，每一行都包含一个自定义参数，例如<kbd>axes.color_cycle: [‘r’, ‘k’, ‘c’]</kbd>。</p><p>可以使用<kbd>matplotlib.matplotlib_fname()</kbd>方法来查找<code>matplotlibrc</code>文件的路径。</p><hr><h2 id="灵感来源"><a class="markdownIt-Anchor" href="#灵感来源"></a> 灵感来源</h2><ol><li>Cyrille Rossant：《Learning IPython for Interactive Computing and Data Visualization》</li><li><a href="https://matplotlib.org/users/customizing.html" target="_blank" rel="noopener">matplotlib docs: Customizing matplotlib</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Data Visualization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> 每日一记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib tutorials</title>
      <link href="/2019/08/04/matplotlib/"/>
      <url>/2019/08/04/matplotlib/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="pyplot教程"><a class="markdownIt-Anchor" href="#pyplot教程"></a> Pyplot教程</h2><p>先导入模块:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>打了这么多字，好累。直接看这吧😂<a href="https://www.gitbook.com/book/wizardforcel/matplotlib-user-guide" target="_blank" rel="noopener">Matplotlib 用户指南</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Visualization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter-ipywidgets使用手册</title>
      <link href="/2019/08/02/jupyter-ipywidgets/"/>
      <url>/2019/08/02/jupyter-ipywidgets/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>封面来源:<a href="https://towardsdatascience.com/lessons-from-a-real-machine-learning-project-part-1-from-jupyter-to-luigi-bdfd0b050ca5" target="_blank" rel="noopener">Medium: Emanuele Fabbiani</a></p></blockquote><p>先导入模块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ipywidgets <span class="keyword">as</span> widgets</span><br></pre></td></tr></table></figure><h2 id="部件集合"><a class="markdownIt-Anchor" href="#部件集合"></a> 部件集合</h2><h3 id="11-数值部件"><a class="markdownIt-Anchor" href="#11-数值部件"></a> 1.1 数值部件</h3><p>数值部件被设计用来显示数值。可以显示整数和浮点数，包括有界的和无界的。大部分数值小部件的参数设置都类似，例如整数滑动条(IntSlider)和浮点数滑动条(FloatSlider)，它们只是名称不同，其功能与参数大致相同。</p><h4 id="111-整数滑动条浮点数滑动条"><a class="markdownIt-Anchor" href="#111-整数滑动条浮点数滑动条"></a> 1.1.1 整数滑动条/浮点数滑动条</h4><p>现在来实现一个整数滑动条：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.IntSlider(</span><br><span class="line">    value=<span class="number">7</span>,<span class="comment"># 设定初始状态，滑动条的值</span></span><br><span class="line">    min=<span class="number">0</span>,<span class="comment"># 设定滑动条最小滑动值</span></span><br><span class="line">    max=<span class="number">10</span>,<span class="comment"># 设定滑动条最大滑动值</span></span><br><span class="line">    step=<span class="number">1</span>,<span class="comment"># 每次移动，改变的步数</span></span><br><span class="line">    description=<span class="string">'Test:'</span>,<span class="comment"># 滑动条的名称，若设置中文，则需要使用unicode编码,例如 u'中国'</span></span><br><span class="line">    disabled=<span class="literal">False</span>,<span class="comment"># 当设置为True时，禁止改变滑动条数值</span></span><br><span class="line">    continuous_update=<span class="literal">False</span>, </span><br><span class="line">    orientation=<span class="string">'horizontal'</span>,<span class="comment"># 设置滑动条的方向：horizontal水平，vertical垂直,默认horizontal</span></span><br><span class="line">    readout=<span class="literal">True</span>,<span class="comment"># 是否显示滑动条当前数值，默认True</span></span><br><span class="line">    readout_format=<span class="string">'d'</span><span class="comment"># 滑动条数值显示格式：d-整数</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p><code>continuous_update</code>的作用: 个人认为作用为是否设置连续更新值，设置为True时，每次修改滑动条数值，都会刷新当前值，并且使得编译器重新编译。而设置为False,则无需重新编译，相当于已经缓存所有滑动条数值。一般设置为False。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802155836.png" alt></p><p>浮点数滑动条与整数滑动条的设置几乎一样，只需改动数值显示格式和使用的方法即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.FloatSlider(</span><br><span class="line">    value=<span class="number">7.0</span>,</span><br><span class="line">    min=<span class="number">0</span>,</span><br><span class="line">    max=<span class="number">10.0</span>,</span><br><span class="line">    step=<span class="number">0.1</span>,</span><br><span class="line">    description=<span class="string">'Test:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    continuous_update=<span class="literal">False</span>,</span><br><span class="line">    orientation=<span class="string">'horizontal'</span>,</span><br><span class="line">    readout=<span class="literal">True</span>,</span><br><span class="line">    readout_format=<span class="string">'.1f'</span>, <span class="comment"># 设置显示的格式为显示一位小数的浮点数</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h4 id="112-浮点指数滑动条"><a class="markdownIt-Anchor" href="#112-浮点指数滑动条"></a> 1.1.2 浮点指数滑动条</h4><p>我们知道指数函数的增长速度是很快的，使用指数函数可以表达很大区间长度的滑动条。</p><p>设置格式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.FloatLogSlider(</span><br><span class="line">    value=<span class="number">10</span>,</span><br><span class="line">    base=<span class="number">10</span>,<span class="comment"># 指数函数的底数</span></span><br><span class="line">    min=<span class="number">-10</span>, <span class="comment"># 指数函数的幂数最小值</span></span><br><span class="line">    max=<span class="number">10</span>, <span class="comment"># 指数函数的幂数最大值</span></span><br><span class="line">    step=<span class="number">0.2</span>, <span class="comment"># 幂数改变的步长</span></span><br><span class="line">    description=<span class="string">'Log Slider'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h4 id="113-整数浮点数区间型滑动条"><a class="markdownIt-Anchor" href="#113-整数浮点数区间型滑动条"></a> 1.1.3 整数/浮点数区间型滑动条</h4><p>IntRangeSlider/FloatRangeSlider可以显示一个区间值对应的滑动条，可以调节区间的大小：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.IntRangeSlider(</span><br><span class="line">    value=[<span class="number">5</span>, <span class="number">7</span>], <span class="comment"># 使用列表的格式设置区间值</span></span><br><span class="line">    min=<span class="number">0</span>,</span><br><span class="line">    max=<span class="number">10</span>,</span><br><span class="line">    step=<span class="number">1</span>,</span><br><span class="line">    description=<span class="string">'Test:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    continuous_update=<span class="literal">False</span>,</span><br><span class="line">    orientation=<span class="string">'horizontal'</span>,</span><br><span class="line">    readout=<span class="literal">True</span>,</span><br><span class="line">    readout_format=<span class="string">'d'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>对于浮点型，设置与整数型区间滑动条类似，可以参考浮点数滑动条。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802155726.png" alt></p><hr><h4 id="114-整数型进度条浮点型进度条"><a class="markdownIt-Anchor" href="#114-整数型进度条浮点型进度条"></a> 1.1.4 整数型进度条/浮点型进度条</h4><p>IntProgress/FloatProgress可以展示进度条效果(静态效果)：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.IntProgress(<span class="comment"># 浮动型只需改为：widgets.FloatProgress</span></span><br><span class="line">    value=<span class="number">7</span>,</span><br><span class="line">    min=<span class="number">0</span>,</span><br><span class="line">    max=<span class="number">10</span>,</span><br><span class="line">    step=<span class="number">1</span>,</span><br><span class="line">    description=<span class="string">'Loading:'</span>,</span><br><span class="line">    bar_style=<span class="string">''</span>, <span class="comment"># 'success', 'info', 'warning', 'danger' or ''</span></span><br><span class="line">    orientation=<span class="string">'horizontal'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在<kbd>bar_style</kbd>参数中,<code>'success', 'info', 'warning', 'danger' or ''</code>代表着进度条显示的不同颜色。</p><hr><h4 id="115-有界整数浮点型数值输入框"><a class="markdownIt-Anchor" href="#115-有界整数浮点型数值输入框"></a> 1.1.5 有界整数/浮点型数值输入框</h4><p>当需要设置输入型的数值框时，可以使用数值的<code>Text</code>部件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># widgets.BoundedFloatText</span></span><br><span class="line">widgets.BoundedIntText( </span><br><span class="line">    value=<span class="number">7</span>,</span><br><span class="line">    min=<span class="number">0</span>,</span><br><span class="line">    max=<span class="number">10</span>,</span><br><span class="line">    step=<span class="number">1</span>,</span><br><span class="line">    description=<span class="string">'Text:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802161038.png" alt></p><p><code>BoundedIntText</code>和<code>BoundedFloatText</code>输入框只能输入有界数值，如果想要输入任意数值，则可用使用<code>IntText</code>/<code>FloatText</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># widgets.FloatText</span></span><br><span class="line">widgets.IntText(</span><br><span class="line">    value=<span class="number">7</span>,</span><br><span class="line">    description=<span class="string">'Any:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="12-布尔控件"><a class="markdownIt-Anchor" href="#12-布尔控件"></a> 1.2 布尔控件</h3><p>布尔控件可以用于展示布尔类型的部件，例如未点击/已点击等。</p><h4 id="121-开关按钮"><a class="markdownIt-Anchor" href="#121-开关按钮"></a> 1.2.1 开关按钮</h4><p>开关按钮(ToggleButton)可以设计类似灯光开关的效果，点击一次打开，再次点击则关闭：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.ToggleButton(</span><br><span class="line">    value=<span class="literal">False</span>, <span class="comment"># 设置初始状态，False代表开关关闭，即未点击状态</span></span><br><span class="line">    description=<span class="string">'Click me'</span>, <span class="comment"># 开关的描述</span></span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    button_style=<span class="string">''</span>, <span class="comment"># 'success', 'info', 'warning', 'danger' or ''</span></span><br><span class="line">    tooltip=<span class="string">'Description'</span>,<span class="comment"># 切换按钮的提示说明,在鼠标悬停在上时显示</span></span><br><span class="line">    icon=<span class="string">'check'</span> <span class="comment"># font-awesome的图标名称，显示在文字描述前</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564734471731.png" alt></p><hr><h4 id="122-复选框"><a class="markdownIt-Anchor" href="#122-复选框"></a> 1.2.2 复选框</h4><p>使用<code>widgets.Checkbox</code>方法可以制造复选框(checkbox)效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.Checkbox(</span><br><span class="line">    value=<span class="literal">False</span>,</span><br><span class="line">    description=<span class="string">'Check me'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p>1.2.3 有效值valid</p><p>valid部件提供只读指示器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.Valid(</span><br><span class="line">    value=<span class="literal">False</span>, <span class="comment"># False代表当前值非法，True则合法</span></span><br><span class="line">    description=<span class="string">'Valid!'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802163451.png" alt></p><hr><h3 id="13-选择部件"><a class="markdownIt-Anchor" href="#13-选择部件"></a> 1.3 选择部件</h3><p>选择部件可用于显示单个选择列表，也可用于选择多个值。我们可以通过传递列表来枚举可选选项。</p><h4 id="131-下拉框"><a class="markdownIt-Anchor" href="#131-下拉框"></a> 1.3.1 下拉框</h4><p>下拉框(Dropdown)设置如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.Dropdown(</span><br><span class="line">    options=[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>], </span><br><span class="line">    value=<span class="string">'2'</span>, <span class="comment"># 默认值</span></span><br><span class="line">    description=<span class="string">'Number:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p><kbd>options</kbd>可以简单设置字符串,如<code>['Galileo', 'Brahe', 'Hubble']</code>,或可用设置数字：<code>[0,1,2]</code>。</p><p>还可以设置键值对：<code>[('Galileo', 0), ('Brahe', 1), ('Hubble', 2)]</code>，此时我们只需设置<kbd>value</kbd>就能选择其对应的字符串。</p></blockquote><hr><h4 id="132-单选框"><a class="markdownIt-Anchor" href="#132-单选框"></a> 1.3.2 单选框</h4><p>RadioButtons效果的设置也很简洁：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.RadioButtons(</span><br><span class="line">    options=[<span class="string">'pepperoni'</span>, <span class="string">'pineapple'</span>, <span class="string">'anchovies'</span>],</span><br><span class="line">value=<span class="string">'pineapple'</span>,</span><br><span class="line">    description=<span class="string">'Pizza topping:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>RadioButtons也可以设置字符串、数字和键值对。</p></blockquote><hr><h4 id="133-选择框"><a class="markdownIt-Anchor" href="#133-选择框"></a> 1.3.3 选择框</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.Select(</span><br><span class="line">    options=[<span class="string">'Linux'</span>, <span class="string">'Windows'</span>, <span class="string">'OSX'</span>],</span><br><span class="line">    value=<span class="string">'OSX'</span>, </span><br><span class="line">rows=<span class="number">3</span>, <span class="comment"># 可选，设置选择的行数。默认行数为options列表中选项个数</span></span><br><span class="line">    description=<span class="string">'OS:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p><kbd>value</kbd>参数可以使用<kbd>index</kbd>参数来代替，该参数可以设置默认值在<kbd>option</kbd>参数列表中的索引值。</p><p>当<kbd>option</kbd>设置是键值对格式时，<kbd>value</kbd>参数也可以使用<kbd>label</kbd>代替，设置为标签名，效果也一样。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802171030.png" alt></p><hr><h4 id="134-选择滑条"><a class="markdownIt-Anchor" href="#134-选择滑条"></a> 1.3.4 选择滑条</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.SelectionSlider(</span><br><span class="line">    options=[<span class="string">'scrambled'</span>, <span class="string">'sunny side up'</span>, <span class="string">'poached'</span>, <span class="string">'over easy'</span>],</span><br><span class="line">    value=<span class="string">'sunny side up'</span>,</span><br><span class="line">    description=<span class="string">'I like my eggs ...'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    continuous_update=<span class="literal">False</span>,</span><br><span class="line">    orientation=<span class="string">'horizontal'</span>,</span><br><span class="line">    readout=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>选择滑动条也可以使用<kbd>index</kbd>和<kbd>label</kbd>参数代替<kbd>value</kbd>。</p></blockquote><hr><p>1.3.5 区间型选择滑条</p><p>SelectionRangeSlider的值、索引和标签键是所选最小值和最大值的2元组。选项必须是非空的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime </span><br><span class="line"><span class="comment"># 使用datetime模块格式化时间</span></span><br><span class="line">dates = [datetime.date(<span class="number">2015</span>,i,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">13</span>)]</span><br><span class="line">options = [(i.strftime(<span class="string">'%b'</span>), i) <span class="keyword">for</span> i <span class="keyword">in</span> dates] <span class="comment"># %b将日期格式化为 月份，如2015-3-1-&gt;Mar</span></span><br><span class="line">widgets.SelectionRangeSlider(</span><br><span class="line">    options=options,</span><br><span class="line">    index=(<span class="number">0</span>,<span class="number">11</span>), <span class="comment"># 选择一月到十二月，元组参数</span></span><br><span class="line">    description=<span class="string">'Months (2015)'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p><kbd>index</kbd>参数可以用<kbd>label</kbd>代替，这里<code>index=(0,11)</code>可以替换为<code>label=('Jan', 'Dec')</code>。</p></blockquote><hr><h4 id="136-开关按钮多个"><a class="markdownIt-Anchor" href="#136-开关按钮多个"></a> 1.3.6 开关按钮(多个)</h4><p>选择部件中的<kbd>ToggleButtons</kbd>与布尔控件中的<kbd>ToggleButton</kbd>参数设置大致相同：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.ToggleButtons(</span><br><span class="line">    options=[<span class="string">'Slow'</span>, <span class="string">'Regular'</span>, <span class="string">'Fast'</span>],</span><br><span class="line">    description=<span class="string">'Speed:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    button_style=<span class="string">''</span>, <span class="comment"># 'success', 'info', 'warning', 'danger' or ''</span></span><br><span class="line">    tooltips=[<span class="string">'Description of slow'</span>, <span class="string">'Description of regular'</span>, <span class="string">'Description of fast'</span>],</span><br><span class="line"><span class="comment">#     icons=['check'] * 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h4 id="137-多选框"><a class="markdownIt-Anchor" href="#137-多选框"></a> 1.3.7 多选框</h4><p>多选部件可以使用<kbd>shift</kbd>和<kbd>ctrl</kbd>(或命令)以及鼠标单击或箭头键选择多个值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.SelectMultiple(</span><br><span class="line">    options=[<span class="string">'Apples'</span>, <span class="string">'Oranges'</span>, <span class="string">'Pears'</span>],</span><br><span class="line">    value=[<span class="string">'Oranges'</span>],</span><br><span class="line">    <span class="comment">#rows=10,</span></span><br><span class="line">    description=<span class="string">'Fruits'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="14-字符部件"><a class="markdownIt-Anchor" href="#14-字符部件"></a> 1.4 字符部件</h3><p>字符部件有接受字符，也有接受HTML和数学公式的小部件</p><h4 id="141-字符输入框"><a class="markdownIt-Anchor" href="#141-字符输入框"></a> 1.4.1 字符输入框</h4><p>单行输入框:<code>Text</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.Text(</span><br><span class="line">    value=<span class="string">'Hello World'</span>,</span><br><span class="line">    placeholder=<span class="string">'Type something'</span>,<span class="comment"># 输入框占位符</span></span><br><span class="line">    description=<span class="string">'String:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多行输入框：<code>Textarea</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.Textarea(</span><br><span class="line">    value=<span class="string">'Hello World'</span>,</span><br><span class="line">    placeholder=<span class="string">'Type something'</span>,</span><br><span class="line">    description=<span class="string">'String:'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h4 id="142-hbox"><a class="markdownIt-Anchor" href="#142-hbox"></a> 1.4.2 HBox</h4><p>当我们想要构建<strong>多个部件</strong>的组合效果时，可以使用Hbox部件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># value内嵌数学公式可用使用$$标识</span></span><br><span class="line"><span class="comment"># widgets.Label()可用定义一个描述文字</span></span><br><span class="line">widgets.HBox([widgets.Label(value=<span class="string">"The $m$ in $E=mc^2$:"</span>), widgets.FloatSlider(),widgets.IntText(value=<span class="number">10</span>)])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803075505.png" alt></p><hr><h4 id="143-html部件"><a class="markdownIt-Anchor" href="#143-html部件"></a> 1.4.3 HTML部件</h4><p>在cell中嵌入HTML代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.HTML(</span><br><span class="line">    value=<span class="string">"Hello &lt;b&gt;World&lt;/b&gt;"</span>,</span><br><span class="line">    placeholder=<span class="string">'Some HTML'</span>,</span><br><span class="line">    description=<span class="string">'Some HTML'</span>, <span class="comment"># HTML代码前的描述文字</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803075654.png" alt></p><hr><h4 id="144-html-math部件"><a class="markdownIt-Anchor" href="#144-html-math部件"></a> 1.4.4 HTML Math部件</h4><p>HTML Math部件可以同时显示HTML代码和数学公式、符号：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.HTMLMath(</span><br><span class="line">    value=<span class="string">r"Some math and &lt;i&gt;HTML&lt;/i&gt;: $x^2$ and $$\frac&#123;x+1&#125;&#123;x-1&#125;$$"</span>,<span class="comment"># 这里使用原始字符串</span></span><br><span class="line">    placeholder=<span class="string">'Some HTML'</span>,</span><br><span class="line">    description=<span class="string">'Some HTML'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803075925.png" alt></p><hr><h3 id="21-图像部件"><a class="markdownIt-Anchor" href="#21-图像部件"></a> 2.1 图像部件</h3><p><kbd>Image</kbd>部件可用结合python文件读取命令来显示图像：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"Deeplearning/sheep.jpg"</span>, <span class="string">"rb"</span>)<span class="comment"># rb：以二进制方式读取</span></span><br><span class="line">image = file.read()</span><br><span class="line">widgets.Image(</span><br><span class="line">    value=image,<span class="comment"># 接受一个字节字符串,是想要浏览器显示的原始图像数据。</span></span><br><span class="line">    format=<span class="string">'jpg'</span>,<span class="comment"># 显式地选择打开图像的格式，默认为'png'</span></span><br><span class="line">    width=<span class="number">300</span>,</span><br><span class="line">    height=<span class="number">400</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803081000.png" alt></p><hr><h3 id="22-按钮"><a class="markdownIt-Anchor" href="#22-按钮"></a> 2.2 按钮</h3><blockquote><p><kbd>Button</kbd>部件与<kbd>ToggleButton</kbd>部件的显示效果差不多，不过，当<kbd>Button</kbd><mark><strong>点击时</strong></mark>，颜色会变深,而当<strong>点击<kbd>ToggleButton</kbd><mark>后</mark></strong>，颜色保持改变。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button = widgets.Button(</span><br><span class="line">    description=<span class="string">'Click me'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    button_style=<span class="string">'success'</span>, <span class="comment"># 'success', 'info', 'warning', 'danger' or ''</span></span><br><span class="line">    tooltip=<span class="string">'Click'</span>,</span><br><span class="line">    icon=<span class="string">'check'</span></span><br><span class="line">)</span><br><span class="line">toggleButton = widgets.ToggleButton(</span><br><span class="line">    value=<span class="literal">False</span>,</span><br><span class="line">    description=<span class="string">'Click me'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span>,</span><br><span class="line">    button_style=<span class="string">'success'</span>,</span><br><span class="line">    tooltip=<span class="string">'Click'</span>,</span><br><span class="line">    icon=<span class="string">'check'</span></span><br><span class="line">)</span><br><span class="line">button</span><br><span class="line">toggleButton</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803082751.png" alt></p><hr><h3 id="23-播放动画部件"><a class="markdownIt-Anchor" href="#23-播放动画部件"></a> 2.3 播放(动画)部件</h3><p>Play小部件通过以一定的速度迭代<strong>整数</strong>序列来执行动画。下面滑块的值链接到播放器:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">play = widgets.Play(</span><br><span class="line"><span class="comment">#     interval=10,时间间隔，用来设置播放速度，默认10s</span></span><br><span class="line">    value=<span class="number">50</span>,</span><br><span class="line">    min=<span class="number">0</span>,<span class="comment"># 设置范围</span></span><br><span class="line">    max=<span class="number">100</span>,</span><br><span class="line">    step=<span class="number">1</span>,<span class="comment"># 每次动画移动步长</span></span><br><span class="line">    description=<span class="string">"Press play"</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">slider = widgets.IntSlider()</span><br><span class="line">widgets.jslink((play, <span class="string">'value'</span>), (slider, <span class="string">'value'</span>))<span class="comment"># 前端链接两个小部件的属性，使它们保持同步</span></span><br><span class="line">widgets.HBox([play, slider])</span><br></pre></td></tr></table></figure><p>这里解释一下<code>widgets.jslink</code>部件的用法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parameters</span><br><span class="line">----------</span><br><span class="line">source : a (Widget, &apos;trait_name&apos;) tuple for the first trait</span><br><span class="line">target : a (Widget, &apos;trait_name&apos;) tuple for the second trait</span><br><span class="line">(指定target的某一属性的与source的同步)</span><br><span class="line"></span><br><span class="line">Examples</span><br><span class="line">--------</span><br><span class="line">&gt;&gt;&gt; c = link((widget1, &apos;value&apos;), (widget2, &apos;value&apos;))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803084322.png" alt></p><hr><h3 id="24-日期选择器"><a class="markdownIt-Anchor" href="#24-日期选择器"></a> 2.4 日期选择器</h3><p><kbd>DatePicker</kbd>部件可以在Chrome、Firefox和IE Edge中工作，但目前不能在Safari中工作，因为它不支持HTML日期输入字段。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.DatePicker(</span><br><span class="line">    description=<span class="string">'Pick a Date'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803085910.png" alt></p><hr><h3 id="25-颜色选择器"><a class="markdownIt-Anchor" href="#25-颜色选择器"></a> 2.5 颜色选择器</h3><p><kbd>ColorPicker</kbd>部件可以选择颜色，并且颜色名称或颜色代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.ColorPicker(</span><br><span class="line">    concise=<span class="literal">False</span>,<span class="comment"># 设置是否隐藏颜色名称或颜色代码</span></span><br><span class="line">    description=<span class="string">'Pick a color'</span>,</span><br><span class="line">    value=<span class="string">'blue'</span>,</span><br><span class="line">    disabled=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190803090404.png" alt></p><hr><h3 id="26-文件上传"><a class="markdownIt-Anchor" href="#26-文件上传"></a> 2.6 文件上传</h3><p><kbd>FileUpload</kbd>部件可用以字节的形式上载任何类型的文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">widgets.FileUpload(</span><br><span class="line">    accept=<span class="string">''</span>,  <span class="comment"># 选择接受的文件类型 e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf'</span></span><br><span class="line">    multiple=<span class="literal">False</span>  <span class="comment"># 设置为True，可以接受多个文件上载</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="31-容器布局部件"><a class="markdownIt-Anchor" href="#31-容器布局部件"></a> 3.1 容器/布局部件</h3><p>这类部件可用用来存储其他称为<kbd>children</kbd>的小部件。每一个容器部件在被创建时或之后，都会有被设置一个<kbd>children</kbd>属性。</p><h4 id="311-box"><a class="markdownIt-Anchor" href="#311-box"></a> 3.1.1 Box</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [widgets.Label(str(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">widgets.Box(items)</span><br></pre></td></tr></table></figure><p><kbd>HBox</kbd> 全称 Horizontal Box，其中所有子项都是自动按顺序<strong>横排</strong>。<kbd>VBox</kbd> 则相反，全称 Vertical Box，里面为<strong>竖排</strong>方式。如果既然要水平方向和垂直方向两个方向填充内容，我们可以相互内嵌布局，即水平布局内嵌垂直布局，或垂直布局内嵌水平布局。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><blockquote></blockquote><p>3.1.2 HBox</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [widgets.Label(str(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">widgets.HBox(items)</span><br></pre></td></tr></table></figure><p>3.1.3 VBox</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [widgets.Label(str(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">left_box = widgets.VBox([items[<span class="number">0</span>], items[<span class="number">1</span>]])</span><br><span class="line">right_box = widgets.VBox([items[<span class="number">2</span>], items[<span class="number">3</span>]])</span><br><span class="line">widgets.HBox([left_box, right_box])</span><br></pre></td></tr></table></figure><hr><h4 id="314-栅格箱gridbox"><a class="markdownIt-Anchor" href="#314-栅格箱gridbox"></a> 3.1.4  栅格箱GridBox</h4><p>此框使用HTML网格规范在<strong>二维网格</strong>中布局其子元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例在3列中列出了其中的8个数字，以及设置容纳这些数字所需的行数。</span></span><br><span class="line">items = [widgets.Label(str(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">widgets.GridBox(items, layout=widgets.Layout(grid_template_columns=<span class="string">"repeat(3, 100px)"</span>))<span class="comment"># 100px代表是每列元素的横向间隔</span></span><br></pre></td></tr></table></figure><hr><h4 id="315-折叠格"><a class="markdownIt-Anchor" href="#315-折叠格"></a> 3.1.5 折叠格</h4><p><kbd>Accordion</kbd>部件可设置折叠效果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accordion = widgets.Accordion(children=[widgets.IntSlider(), widgets.Text()]) <span class="comment"># 设置children部件</span></span><br><span class="line">accordion.set_title(<span class="number">0</span>, <span class="string">'Slider'</span>) <span class="comment"># 折叠格的名称</span></span><br><span class="line">accordion.set_title(<span class="number">1</span>, <span class="string">'Text'</span>)</span><br><span class="line">accordion</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804104229.png" alt></p><hr><h4 id="316-选项卡"><a class="markdownIt-Anchor" href="#316-选项卡"></a> 3.1.6 选项卡</h4><p><kbd>Tab</kbd>部件的<kbd>children</kbd>是在选项卡创建后，添加的属性。每一个选项的标题设置与<kbd>Accordion</kbd>相同：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tab_contents = [<span class="string">'P0'</span>, <span class="string">'P1'</span>, <span class="string">'P2'</span>, <span class="string">'P3'</span>, <span class="string">'P4'</span>]<span class="comment"># 标题</span></span><br><span class="line">children = [widgets.Text(description=name) <span class="keyword">for</span> name <span class="keyword">in</span> tab_contents]</span><br><span class="line">tab = widgets.Tab()<span class="comment"># 先创建Tab部件</span></span><br><span class="line">tab.children = children<span class="comment"># 创建部件后，再添加children属性</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(children)):</span><br><span class="line">    tab.set_title(i, str(i))</span><br><span class="line">tab</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804104555.png" alt></p><hr><p><kbd>Tab</kbd>和<kbd>Accordion</kbd>部件在选择不同选项或者折叠格时，它们会自动更新<code>selected_index</code>属性，即选项对应的索引。<strong>这与之前选择部件都不同</strong>。</p><blockquote><p>这意味着我们既可以查看用户正在做什么，也可以通过设置<code>selected_index</code>的值以编程方式设置用户看到的内容。</p></blockquote><p>当设置<code>selected_index = None</code>关闭所有折叠格或取消选择所有选项卡。例如我们设置取消选择所有选项卡，则选项卡内部件会消失：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tab..selected_index = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804105413.png" alt></p><hr><h4 id="317-嵌套选项卡和折叠格"><a class="markdownIt-Anchor" href="#317-嵌套选项卡和折叠格"></a> 3.1.7 嵌套选项卡和折叠格</h4><p>选项卡和折叠格可以嵌套到任意深度。下面举一例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tab_nest = widgets.Tab()</span><br><span class="line">accordion = widgets.Accordion(children=[widgets.IntSlider(), widgets.Text()]) <span class="comment"># 设置children部件</span></span><br><span class="line">accordion.set_title(<span class="number">0</span>, <span class="string">'Slider'</span>) <span class="comment"># 折叠格的名称</span></span><br><span class="line">accordion.set_title(<span class="number">1</span>, <span class="string">'Text'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始嵌套</span></span><br><span class="line">tab_nest.children = [accordion, accordion]</span><br><span class="line">tab_nest.set_title(<span class="number">0</span>, <span class="string">'An accordion'</span>)<span class="comment"># 设置选项卡标题</span></span><br><span class="line">tab_nest.set_title(<span class="number">1</span>, <span class="string">'Copy of the accordion'</span>)</span><br><span class="line">tab_nest</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804105712.png" alt></p><hr><h3 id="output部件"><a class="markdownIt-Anchor" href="#output部件"></a> 🖨 Output部件</h3><h4 id="更加人性化的输出显示-ipython"><a class="markdownIt-Anchor" href="#更加人性化的输出显示-ipython"></a> 更加人性化的输出显示: IPython</h4><p>在IPython 5.4和6.1自动向用户提供<code>display()</code>，而不需要导入。如果在纯python上下文中或旧版本的IPython中使用display，请在文件顶部使用以下导入:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br></pre></td></tr></table></figure><p>Output部件可以捕获和显示由IPython生成的stdout、stderr和Rich output。我们还可以直接将输出追加到输出部件，或者通过编程清除它。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置一个Output对象</span></span><br><span class="line">out = widgets.Output(layout=&#123;<span class="string">'border'</span>: <span class="string">'1px solid yellow'</span>&#125;)<span class="comment"># 定制布局：增加输出外框</span></span><br></pre></td></tr></table></figure><p>Rich output可以被定向到输出区域。在Jupyter中能够很好展示的输出都能在<kbd>Output</kbd>部件中很好展示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> YouTubeVideo</span><br><span class="line">out = widgets.Output(layout=&#123;<span class="string">'border'</span>: <span class="string">'1px solid yellow'</span>&#125;)</span><br><span class="line"><span class="comment"># 使用 with out 来保持Output部件的输出窗口</span></span><br><span class="line"><span class="keyword">with</span> out:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(i, <span class="string">'Hello world!'</span>)</span><br><span class="line">    display(YouTubeVideo(<span class="string">'eWzY2nGfkXk'</span>)) <span class="comment"># 可以展示任意部件，甚至视频</span></span><br><span class="line">    </span><br><span class="line">out</span><br></pre></td></tr></table></figure><blockquote><p>🔖 注意：Output部件会将所有输出都一致输出到out窗口中。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804111953.png" alt></p><hr><p>我们也可以使用<kbd>append_stdout</kbd>、<kbd>append_stderr</kbd>和<kbd>append_display_data</kbd>方法来将输出直接附加到output小部件。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804112418.png" alt></p><blockquote><p>⚠️ 注意，<code>append_display_data</code>目前不能用于显示小部件.</p></blockquote><p>我们可以使用<code>IPython.display</code>清除输出。或者我们可以直接调用小部件的<code>clear_output</code>方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.clear_output()</span><br></pre></td></tr></table></figure><p><code>clear_output</code>方法可以传入<code>wait</code>参数，若设置为<code>True</code>,则<code>clear_output</code>方法不会直接清除输出，而是当小部件下次收到要显示的内容时，它们将被清除。这在替换output小部件中的内容时非常有用:它通过避免在调用<code>clear_output</code>后对小部件的大小进行不协调的调整，从而实现更平滑的转换。</p><hr><h4 id="交互基础的输出小部件"><a class="markdownIt-Anchor" href="#交互基础的输出小部件"></a> 交互基础的输出小部件</h4><p>输出部件本身也可以用来创建带有小部件和代码输出的丰富布局。定制交互UI外观的一个简单方法是使用<code>interactive_output</code>函数将控件连接到返回的output小部件中捕获输出的函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = widgets.IntSlider(description=<span class="string">'a'</span>)</span><br><span class="line">b = widgets.IntSlider(description=<span class="string">'b'</span>)</span><br><span class="line">c = widgets.IntSlider(description=<span class="string">'c'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125;*&#123;&#125;*&#123;&#125;=&#123;&#125;'</span>.format(a, b, c, a*b*c))</span><br><span class="line"></span><br><span class="line">out = widgets.interactive_output(f, &#123;<span class="string">'a'</span>: a, <span class="string">'b'</span>: b, <span class="string">'c'</span>: c&#125;)<span class="comment"># 第一个参数： 交互输出函数， 第二个参数： 传递参数值</span></span><br><span class="line">widgets.HBox([widgets.VBox([a, b, c]), out])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190804114510.png" alt></p><hr><h2 id="resource"><a class="markdownIt-Anchor" href="#resource"></a> Resource</h2><ol><li><a href="https://ipywidgets.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">ipywidgets docs</a></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/zhangxin09/article/details/5631640" target="_blank" rel="noopener">CSDN: sp42a 箱子布局攻略 (HBox/VBox Layout)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Jupyter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Jupyter Widgets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas_cookbook</title>
      <link href="/2019/08/02/pandas-cookbook/"/>
      <url>/2019/08/02/pandas-cookbook/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a><h2 id="读取csv文件"><a class="markdownIt-Anchor" href="#读取csv文件"></a> 读取csv文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'xx.csv'</span>,, sep=<span class="string">';'</span>, encoding=<span class="string">'latin1'</span>, parse_dates=[<span class="string">'Date'</span>], dayfirst=<span class="literal">True</span>, index_col=<span class="string">'Date'</span>)</span><br><span class="line"><span class="comment"># 'xx.csv'也可以是某个网页url</span></span><br></pre></td></tr></table></figure><ul><li><p><code>sep=';'</code>将字段分隔符改为<code>;</code>。字符类型，指定分隔符。默认使用&quot;,&quot;分割（csv文件一般以逗号分割)</p></li><li><p><code>names</code>: array-like 可以设置添加表头，如数据有表头，但想用新的表头，可以设置<code>header=0,names=['a','b']</code>实现表头定制。</p></li><li><p><code>header</code></p><ul><li><code>header=None</code>表示原始文件没有列索引，这样该命令会自动加上列索引</li><li><code>header=0</code>:表示文件<strong>第1行</strong>为列索引，可以添加<strong>names</strong>来替换原来的列索引(可以使用range函数)</li></ul></li><li><p><code>encoding='latin1'</code>修改编码格式为<code>'latin1'</code> (默认是 <code>'utf8'</code>)</p></li><li><p><code>parse_dates=['Date']</code>处理 'Date’字段的日期格式</p></li><li><p><code>dayfirst=True</code>告诉pandas日期的格式是“天”在前而不是“月”在前</p></li><li><p><code>index_col='Date'</code>将Date列设为索引（Index）。</p><ul><li><code>index_col</code>：指定数据中<strong>哪一列</strong>作为Dataframe的行索引,也可以指定多列形成层次索引，默认为None.系统会自动加上行索引。</li></ul></li></ul><p>其他参数：</p><ul><li><code>delimiter</code>:字符类型，定界符，若指定该参数，则sep失效</li><li><code>skiprows=n</code>: 忽略前n行数据</li><li><code>parse_dates</code>:<ul><li>布尔类型： 解析索引</li><li>列表/整数/表头(names): 如[1,2,3]-&gt;解析<strong>1，2，3列</strong>的值作为独立日期列</li><li>嵌套列表：如[[1,3]]-&gt;==<strong>合并</strong>==1，3列作为ig日期列使用<br>字典：如<code>{'foo':[1,3]}</code>-&gt;将1，3列合并，合并列起名为<code>'foo'</code></li><li>日期显示格式：<br><code>dayfirst</code> : boolean, default False :Day/Month格式的日期类型</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parse_dates实例</span></span><br><span class="line"><span class="comment"># 将time1和time2两列解析为日期格式</span></span><br><span class="line">df=pd.read_csv(file_path,parse_dates=[<span class="string">'time1'</span>,<span class="string">'time2'</span>])</span><br></pre></td></tr></table></figure><ul><li><code>na_values= NaN</code>: 标量/str等，设置一组用于替换NA/NaN的值</li><li><code>na_filter=False</code>:boolean, default True，是否检查丢失值（空字符串或者是空值）对于大文件来说数据集中没有空值，设定na_filter=False可以提升读取速度</li><li><code>thousands=','</code>: str, default None 千分位分割符，如“，”或者“.&quot;</li><li><code>usecols</code>:可以指定原数据集中，<strong>所使用的列</strong>。当<code>usecols=[0,1,2,3]</code>时，即选中前4列，之后令第一列为行索引.</li><li><code>nrows</code>：可以给出从原始数据集中的所读取的<strong>行数</strong>，目前只能从第一行开始到nrows行</li></ul><p>如果想要修改dataframe的一些列名：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns = [ ... ]</span><br></pre></td></tr></table></figure><hr><h2 id="读取数据集的相关信息"><a class="markdownIt-Anchor" href="#读取数据集的相关信息"></a> 读取数据集的相关信息</h2><p>获取数据集中观察值的个数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">observations = df.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">observations.info() <span class="comment"># 该方法更加推荐，可以获得详细信息</span></span><br></pre></td></tr></table></figure><p>获取数据集的列数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colsNum = df.shape[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>获取数据集所有列的名称:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colsName = df.columns</span><br></pre></td></tr></table></figure><p>获取数据集的索引情形：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_index = df.index</span><br></pre></td></tr></table></figure><p>直接使用索引作为Dataframe属性：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对df的col_1查看其数据类型</span></span><br><span class="line">df.col_1.dtype</span><br></pre></td></tr></table></figure><p>将col_1数据类型进行转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用apply方法可以传入一个函数，并对数据进行操作</span></span><br><span class="line">trans = = <span class="keyword">lambda</span> x: float(x[<span class="number">1</span>:<span class="number">-1</span>])<span class="comment"># 使用匿名函数转换</span></span><br><span class="line">df.col_1 = df.col_1.apply(trans)</span><br></pre></td></tr></table></figure><hr><h2 id="切片索引"><a class="markdownIt-Anchor" href="#切片索引"></a> 切片索引</h2><p>将数据绘制成图像：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_ = df.plot(figsize=(<span class="number">15</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>获取前1行到最后一行数据:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="number">1</span>:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>选取第一列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[:<span class="number">6</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>选取多列数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取索引名为index1和index2的两列数据</span></span><br><span class="line">df[[<span class="string">'index1'</span>, <span class="string">'index2'</span>]]</span><br></pre></td></tr></table></figure><p>只选取前10行：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">'index1'</span>, <span class="string">'index2'</span>]][:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>使用条件索引获取相应数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取df中索引名为index的列中，所有值为1的数据</span></span><br><span class="line">df[df[<span class="string">'index'</span>] == <span class="number">1</span>] <span class="comment"># df[index] = 1得到一个布尔值列表</span></span><br></pre></td></tr></table></figure><p>也可以结合布尔操作来获取条件数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value_larger_one = (df[<span class="string">'index'</span>] &gt; <span class="number">1</span>)</span><br><span class="line">value_less_zero  = (df[<span class="string">'index'</span>] &lt; <span class="number">0</span>)</span><br><span class="line">df[value_larger_one | value_less_zero ] <span class="comment"># "或"条件，"和"条件可以使用&amp;，"非"：!</span></span><br></pre></td></tr></table></figure><p>返回Dataframe的索引：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index <span class="comment"># 返回一个索引列表，以及索引的相关属性</span></span><br><span class="line"><span class="comment"># 也可以对index重新赋值</span></span><br><span class="line">df.index = [...]</span><br></pre></td></tr></table></figure><p>pandas有一系列获取time series的函数，可以获得每一行数据对应的每个月第几天，星期几：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index.day</span><br><span class="line">df.index.weekday</span><br></pre></td></tr></table></figure><hr><h2 id="统计"><a class="markdownIt-Anchor" href="#统计"></a> 统计</h2><p>统计每项索引数据的总数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'index'</span>].value_counts()</span><br></pre></td></tr></table></figure><p>只观察最多的5项：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'index'</span>].value_counts()[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>更直观地绘制柱状图：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'index'</span>].value_counts().plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p>Dataframe可以使用<code>groupby()</code>方法，对数据进行分类。也可以用作统计数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df.groupby('index_name').aggregate(sum) 的意思就是说，首先将数据按照索引index_name内容分组，然后对每一组的数据求和。</span></span><br><span class="line">df_counts = df.groupby(<span class="string">'index_name'</span>).aggregate(sum)</span><br><span class="line"><span class="comment"># 这里的sum函数还可以换为其他的统计函数，例如max、numpy.median,...</span></span><br><span class="line"><span class="comment"># 也可以直接对分组对象使用sum函数</span></span><br><span class="line">df.groupby(<span class="string">'index_name'</span>).sum()</span><br></pre></td></tr></table></figure><p>使用<code>dropna</code>函数丢弃数据中一些几乎全为空的列</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dropna中的参数axis=1的意思是去掉整列而不是行</span></span><br><span class="line"><span class="comment"># how=‘any’的意思是任何有空值的列都去掉</span></span><br><span class="line">df = df.dropna(axis=<span class="number">1</span>, how=<span class="string">'any'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ <code>dropna</code>函数只是将包含空值的列数据都删去，而不删除列。</p></blockquote><p>如果想要删除整个列，则需要使用<code>drop</code>函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用drop函数，删除指定的列index1, index2</span></span><br><span class="line">df = df.drop([<span class="string">'index1, index2'</span>], axis=<span class="number">1</span>) <span class="comment"># axis=1同样表示删除整列，默认是删除整行</span></span><br></pre></td></tr></table></figure><p>使用<code>resample()</code>方法，将df数据进行重采样，可对时间序列数据重新采样和频率转换</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">freq： 表示重采样频率，例如‘M'、‘5min'，Second(15)</span></span><br><span class="line"><span class="string">how：用于产生聚合值的函数名或数组函数</span></span><br><span class="line"><span class="string">closed： 在降采样时，各时间段的哪一段是闭合的，‘right'或‘left'，默认‘right'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">_ = df[<span class="string">'index'</span>].resample(<span class="string">'M'</span>, how=np.median)</span><br></pre></td></tr></table></figure><p>使用<code>sort_values</code>方法将数据按索引进行排序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对分组为item的数据，根据索引index进行降序排序</span></span><br><span class="line">c = df.groupby(<span class="string">'item'</span>)</span><br><span class="line">c = c.sum()</span><br><span class="line">c = c.sort_values([<span class="string">'index'</span>], ascending=<span class="literal">False</span>)</span><br><span class="line">c.head(<span class="number">1</span>)<span class="comment"># 获取数目最多的item数据</span></span><br></pre></td></tr></table></figure><hr><h2 id="pandas的series与numpy的array关系"><a class="markdownIt-Anchor" href="#pandas的series与numpy的array关系"></a> pandas的Series与Numpy的array关系</h2><p>DataFrame中的每一列都是<code>pd.Series</code>类型的数据。pandas中Series类型的数据实际上是numpy array类型的数据，如果我们对任何<code>Series</code>类型的数据使用<code>.values</code>方法，则可以得到内部的numpy array。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">返回结果</span></span><br><span class="line"><span class="string">0    1</span></span><br><span class="line"><span class="string">1    2</span></span><br><span class="line"><span class="string">2    3</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).values</span><br><span class="line"><span class="comment"># array([1,2,3])</span></span><br><span class="line"></span><br><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># array([1,2,3])</span></span><br></pre></td></tr></table></figure><blockquote><p>💡 数组的二值化操作：对数据进行条件判断，返回一个布尔值列表，满足条件的数据值为True,代表1；不满足的即为False，代表0.</p><p>可以将二值化向量转换为0,1表示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; vec.astype(float)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><blockquote><p>💡 在python2版本中，除法是使用整除，即取整去余，而在python3中，则是返回浮点型。为了使得python2中也返回浮点型，可以导入模块<code>from __future__ import division</code>。</p></blockquote><hr><h2 id="拷贝与融合数据"><a class="markdownIt-Anchor" href="#拷贝与融合数据"></a> 拷贝与融合数据</h2><p>拷贝所需的Dataframe:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_copy = df[[<span class="string">'index'</span>]].copy()</span><br></pre></td></tr></table></figure><p>向Dataframe中添加新的列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[:, <span class="string">'index_name'</span>] <span class="comment"># 第二个属性是给新添加的列的索引</span></span><br></pre></td></tr></table></figure><p>使用<code>concat</code>函数可以将所有数据融合在一起：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将dataframe#2数据与dataframe#1融合</span></span><br><span class="line">df = pd.concat([df_1, df_2])</span><br></pre></td></tr></table></figure><hr><h2 id="字符串操作"><a class="markdownIt-Anchor" href="#字符串操作"></a> 字符串操作</h2><p>pandas提供了一些向量化的函数，来处理某些列是否包含<strong>指定字符串</strong>的问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查dataframe某列中是否包含字符串'string'</span></span><br><span class="line">is_string = df[<span class="string">'index'</span>].str.contains(<span class="string">'string'</span>) <span class="comment"># 返回了一个二值向量</span></span><br></pre></td></tr></table></figure><p>将字符串切片：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.str.slice(start, end) <span class="comment"># 参数为切割的索引区间，只取这个区间内的字符串</span></span><br></pre></td></tr></table></figure><p>当想要对数字字符串进行<strong>排序</strong>，可以使用<code>sort()</code>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设我们选取index1,index2,index3三列，并且按照index1列数字排序</span></span><br><span class="line">df[[<span class="string">'index1'</span>,<span class="string">'index2'</span>,<span class="string">'index3'</span>]].sort(<span class="string">'index1'</span>)</span><br><span class="line"><span class="comment"># sort方法还可以传入参数ascending,指定排序是升序还是降序</span></span><br></pre></td></tr></table></figure><p>若想将所有字符串大写，可用如下操作:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'index'</span>].str.upper()</span><br></pre></td></tr></table></figure><hr><h2 id="处理脏数据"><a class="markdownIt-Anchor" href="#处理脏数据"></a> 处理&quot;脏&quot;数据</h2><p>为了检查数据，可以先使用<code>.unique()</code>方法将dataframe中所有值列出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.unique()</span><br></pre></td></tr></table></figure><p>当一些空值没有被pandas处理，而被转换为类似’N/A’ 和’NO CLUE’的字符串类型，则我们需要将其转换为通常的nan类型.还可能有一些数据是浮点型，而被转换为了字符串型。我们需要将所有数据都转换为string类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在读取csv文件时，可以传入na_values参数来处理这些缺失值</span></span><br><span class="line"><span class="comment"># 指定csv文件中需要转换为string类型的列index</span></span><br><span class="line">na_values = [<span class="string">'NO CLUE'</span>, <span class="string">'N/A'</span>, <span class="string">'0'</span>] <span class="comment"># 定义缺失值可能形式的列表</span></span><br><span class="line">df = pd.read_csv(<span class="string">'../xx.csv'</span>, na_values=na_values, dtype=&#123;<span class="string">'index'</span>: str&#125;))</span><br></pre></td></tr></table></figure><hr><h2 id="时间戳处理"><a class="markdownIt-Anchor" href="#时间戳处理"></a> 时间戳处理</h2><p>用pandas解析时间戳最神奇的地方在于，numpy的datetimes本身就是以unix的时间戳形式保存的，因此，我们要做的就是，告诉pandas这些int型数据就是时间戳。</p><p>如果我们有一个时间段用秒或者微秒来表示的，那么直接转换<code>datetime64</code>类型，pandas就可以帮我们处理了。</p><p>我们可以使用<code>pd.to_datetime</code>函数来完成int型时间戳到datetime类型的转换:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先将时间戳对应的列数据由字符串转换为int类型</span></span><br><span class="line">df[<span class="string">'time_stamp'</span>] = df[<span class="string">'time_stamp'</span>].astype(int) <span class="comment"># 强制转换</span></span><br><span class="line">df[<span class="string">'time_stamp'</span>] = pd.to_datetime(df[<span class="string">'time_stamp'</span>], unit=<span class="string">'s'</span>)</span><br><span class="line"><span class="comment"># 此时，time_stamp列的数据类型变为&lt;M8[ns]，即datetime64</span></span><br></pre></td></tr></table></figure><blockquote><p><code>to_datetime</code>函数可用指定格式化日期时间，如:<code>pd.to_datetime('2019/8/3 10:24:48', format='%Y/%m/%d %H:%M:%S')</code></p></blockquote><blockquote><p>其中参数<code>unit</code>是输入数据的单位，其为字符串类型：<code>string[D,s,ms,us,ns]</code>,默认是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup><mi>n</mi><msup><mi>s</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">&#x27;ns&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>.</p></blockquote><hr><h2 id="保存文件"><a class="markdownIt-Anchor" href="#保存文件"></a> 保存文件</h2><p>将数据直接保存到本地的csv文件，方便以后读取：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(<span class="string">'../xx/data.csv'</span>) <span class="comment"># 存储目录</span></span><br></pre></td></tr></table></figure><hr><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference🔗</h2><ol><li><a href="https://github.com/jvns/pandas-cookbook" target="_blank" rel="noopener">Github: pandas-cookbook</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> pandas-cookbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法图解》学习笔记：上部</title>
      <link href="/2019/08/02/Algorithm-1/"/>
      <url>/2019/08/02/Algorithm-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文章中有大量图片，初次加载可能会比较慢<sub>(￣▽￣)</sub>*</p></blockquote><a id="more"></a><h2 id="chapter-i-算法简介"><a class="markdownIt-Anchor" href="#chapter-i-算法简介"></a> Chapter Ⅰ 算法简介</h2><h3 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h3><h4 id="easy-learning"><a class="markdownIt-Anchor" href="#easy-learning"></a> Easy-Learning</h4><p><strong>简单查找</strong>：想象我们现在正在玩猜数字的游戏。我们在0-100中猜数字，每次猜测只能排除一个数字，假设设定的猜测数为99，如果我们按照1，2，3,…顺序猜测，那么将要猜测99次才能猜中。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564490148254.png" alt></p><p><strong>二分查找</strong>：当我们希望在一个很大的数据集中查找某一个数据，例如在网站数据库中寻找某一个用户名信息。如果我们从第一个用户名字母&quot;A&quot;开始查对，如果该用户名排名很后，将会非常耗时。然而，我们可以选择从中间字母，例如&quot;L&quot;字母开始查找。这种从中间开始查找的思想就是二分查找算法的核心。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564490173328.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564490271061.png" alt></p><hr><p>二分查找算法的输入是一个<strong>有序</strong>的元素列表。如果要查找的元素包含在列表中，二分查找返回其索引位置；否则返回null。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564489847814.png" alt></p><p>由猜数字的例子，我们可以推导出二分查找与简单查找的步数对比：<strong>一般而言，对于包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个元素的列表，用二分查找最多需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>步，而简单查找最多需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>步</strong>。</p><hr><h4 id="python实现"><a class="markdownIt-Anchor" href="#python实现"></a> python实现</h4><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564492069757.png" alt></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参数说明：</span></span><br><span class="line"><span class="string">        list: 需要查找的值所在的列表</span></span><br><span class="line"><span class="string">        item: 需要查找的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取列表的初始两端的索引，即为查找的索引范围</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list) - <span class="number">1</span> <span class="comment"># 列表长度减1即为最后一个元素的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment"># 设置终止条件，当low=high时，说明整个list都被遍历了</span></span><br><span class="line">        <span class="comment"># 获取中间位置元素的索引</span></span><br><span class="line">        mid = int((low + high) / <span class="number">2</span>) <span class="comment"># 在python2中会自动将mid向下取整，而pyhton3会得到浮点型，则需将其转为整数类型，也可以使用math模块的floor方法</span></span><br><span class="line">        guess = list[mid] <span class="comment"># 选取list列表的中间值为猜测值</span></span><br><span class="line">        <span class="comment"># 当找到匹配值时，将其索引返回</span></span><br><span class="line">        <span class="keyword">if</span> guess == item:   </span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># 条件判断：若猜测值比真实值小，则修改low,反之则修改high</span></span><br><span class="line">        <span class="keyword">if</span> guess &lt; item:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h4 id="算法运行时间"><a class="markdownIt-Anchor" href="#算法运行时间"></a> 算法运行时间</h4><p>一般而言，我们应选择效率最高的算法，以最大限度地减少运行时间或占用空间。</p><p>假设列表包含40亿个数字，则简单查找逐个地检查数字，最多需要猜40亿次，即最多需要猜测的次数与列表长度相同，这被称为<strong>线性时间</strong>（linear time）；而二分查找最多只需猜测32次，其运行时间为<strong>对数时间</strong>（或log时间）</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564492317190.png" alt></p><hr><h3 id="大o表示法"><a class="markdownIt-Anchor" href="#大o表示法"></a> 大O表示法</h3><p>大O表示法是一种特殊的表示法，可以衡量算法的运行速度的快慢。</p><h4 id="算法运行时间以不同速度增加"><a class="markdownIt-Anchor" href="#算法运行时间以不同速度增加"></a> 算法运行时间以不同速度增加</h4><p>假设现在Bob要为NASA(美国国家航空航天局，梦想之地ヾ(≧▽≦*)o)编写一个查找算法，帮助计算着陆地点。</p><p>Bob需要做出决定，是使用简单查找还是二分查找。使用的算法必须快速而准确。 一方面，二分查找的速度更快。Bob必须在10秒钟内找出着陆地点，否 则火箭将偏离方向。另一方面，简单查找算法编写起来更容易，因此出现bug的可能性更小。Bob可不希望引导火箭着陆的代码中有bug！为确保万无一失，Bob决定计算两种算法在列表包含100个元素的情况下需要的时间。</p><p>假设检查一个元素需要1毫秒。使用简单查找时，Bob必须检查100个元素，因此需要100毫秒才能查找完毕。而使用二分查找时，只需检查7个元素（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mn>100</mn></mrow><annotation encoding="application/x-tex">\log_2100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>大约为7），因此需要7毫秒就能查找完毕。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564492877918.png" alt></p><p>当列表包含100个元素时，简单查找需要100毫秒，而二分查找需要7毫秒，经计算，二分查找的速度大约为简单查找的15倍。而当列表元素为1000，10000，…时，这个倍数关系还是否成立？</p><p>答案是不成立。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="red"><mrow><mi mathvariant="normal">因</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">二</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mi mathvariant="normal">和</mi><mi mathvariant="normal">简</mi><mi mathvariant="normal">单</mi><mi mathvariant="normal">查</mi><mi mathvariant="normal">找</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">增</mi><mi mathvariant="normal">速</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">同</mi><mi mathvariant="normal">。</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{因为二分查找和简单查找的运行时间的增速不同。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">因</span><span class="mord cjk_fallback" style="color:red;">为</span><span class="mord cjk_fallback" style="color:red;">二</span><span class="mord cjk_fallback" style="color:red;">分</span><span class="mord cjk_fallback" style="color:red;">查</span><span class="mord cjk_fallback" style="color:red;">找</span><span class="mord cjk_fallback" style="color:red;">和</span><span class="mord cjk_fallback" style="color:red;">简</span><span class="mord cjk_fallback" style="color:red;">单</span><span class="mord cjk_fallback" style="color:red;">查</span><span class="mord cjk_fallback" style="color:red;">找</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">运</span><span class="mord cjk_fallback" style="color:red;">行</span><span class="mord cjk_fallback" style="color:red;">时</span><span class="mord cjk_fallback" style="color:red;">间</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">增</span><span class="mord cjk_fallback" style="color:red;">速</span><span class="mord cjk_fallback" style="color:red;">不</span><span class="mord cjk_fallback" style="color:red;">同</span><span class="mord cjk_fallback" style="color:red;">。</span></span></span></span></span></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564493011456.png" alt></p><p>也就是说，随着元素数量的增加，二分查找需要的额外时间并不多，<br>而简单查找需要的额外时间却很多。当列表包含10亿个元素时，为==<strong>3300万倍</strong>==。</p><p>有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，更有意义的是知道运行时间随列表增长而增加的速度。这正是大O表示法的用武之地。</p><p>大O表示法指出了算法运行时间的增速。例如，假设列表包含n个元素。简单查找需要检查每个元素，因此需要执行n次操作。使用大O表示法，这个运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><p>而对于二分查找，为检查长度为n的列表，其需要执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>次操作。使用大O表示法，为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>在这里默认以2为底数。</p></blockquote><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564493434859.png" alt></p><hr><h4 id="理解不同的大o运行时间"><a class="markdownIt-Anchor" href="#理解不同的大o运行时间"></a> 理解不同的大O运行时间</h4><p>以在白纸上画网格为例：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564493584187.png" alt></p><p><strong>算法1</strong>：简单查找算法实现，则是以每次画一个格式的方式，重复16次：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564493626897.png" alt></p><p><strong>算法2</strong>：二分查找方式，则是每次将纸对折，然后沿着虚线画条线，则第一次对称相当于画了两个格子，重复操作。最终我们只需折4次后再打开，就得到16个格子。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564493757482.png" alt></p><p>可知算法1的运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，算法2的运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><hr><h4 id="大o表示法指出最糟情况下的运行时间"><a class="markdownIt-Anchor" href="#大o表示法指出最糟情况下的运行时间"></a> 大O表示法指出最糟情况下的运行时间</h4><p>例如使用简单查找方式在电话簿中查找人。如果电话簿中一共有n个电话号码，则算法最多查找n次，那么其运行时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><p>如果查找一次就找到了，这当然是最佳情形，但大O表示法说的是最糟的情形。在最糟情况下，必须查看电话簿中的每个条目，对应的运行时间为O(n)。这是一个保证——你知道简单查找的运行时间不可能超过O(n)。</p><hr><h4 id="常见的大o运行时间"><a class="markdownIt-Anchor" href="#常见的大o运行时间"></a> 常见的大O运行时间</h4><ul><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，也叫对数时间，这样的算法包括二分查找。</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，也叫线性时间，这样的算法包括简单查找。</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n * \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，这样的算法包括第4章将介绍的<strong>快速排序</strong>——一种速度较快的排序算法。</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这样的算法包括第2章将介绍的<strong>选择排序</strong>——一种速度较慢的排序算法。</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>，这样的算法包括接下来将介绍的<strong>旅行商问题</strong>的解决方案——一种非常慢的算法。</p></li></ul><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564494632322.png" alt></p><p>对于大O表示法，我们可以得到如下启示：</p><ul><li><p>算法的速度指的并非时间，而是操作数的<strong>增速</strong>。</p></li><li><p>谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。</p></li><li><p>算法的运行时间用大O表示法表示。</p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>快，当需要搜索的元素越多时，前者比后者快得越多。</p></li></ul><p>大O表示法的一条简单规则是，大O表示法不考虑乘以、除以、加上或减去的数字。下面这些都不是正确的大O运行时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>26</mn><mo stretchy="false">)</mo><mi mathvariant="normal">、</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>26</mn><mo stretchy="false">)</mo><mi mathvariant="normal">、</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mn>26</mn><mo stretchy="false">)</mo><mi mathvariant="normal">、</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + 26)、O(n - 26)、O(n * 26)、O(n / 26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>，它们都应表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>！</p><hr><h3 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h3><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564543047841.png" alt></p><p>对于每种顺序，他都需要计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。因此，在涉及5个城市时，解决这个问题需要执行120次操作。涉及6个城市时，需要执行720 次操作（有720种不同的排列方式）。涉及7个城市时，需要执行5040次操作！</p><p>推而广之，涉及n个城市时，需要执行n!（n的阶乘）次操作才能计算出结果。因此运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作.</p><p>这就是计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快。对于这个问题，目前还没有找到更快的算法，有些很聪明的人认为这个问题根本就没有更巧妙的算法。</p><hr><h2 id="chapter-ii-选择排序"><a class="markdownIt-Anchor" href="#chapter-ii-选择排序"></a> Chapter Ⅱ 选择排序</h2><h3 id="内存的工作原理"><a class="markdownIt-Anchor" href="#内存的工作原理"></a> 内存的工作原理</h3><p>把内存想象成很多的抽屉的集合，每个抽屉都有其对应的位置，即地址。在抽屉里可以存放物体，即存储值。</p><p>当需要将数据存储到内存时，我们向计算机请求提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——<strong>数组和链表</strong>。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564544074403.png" alt></p><hr><h3 id="数组和链表"><a class="markdownIt-Anchor" href="#数组和链表"></a> 数组和链表</h3><p>假设我们需要编写一个管理代办事项的应用程序，需要在内存中存储一系列代办事项。</p><p>鉴于数组更容易掌握，我们先将待办事项存储在数组中。使用数组意味着所有待办事项在内存中都是<strong>相连</strong>的（紧靠在一起的）。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564544328110.png" alt></p><p>现在假设你要添加第四个待办事项，但后面的那个抽屉放着别人的东西！在这种情况下，我们只能请求计算机重新分配一块可容纳4个待办事项的内存，再将所有待办事项都移到那里。</p><p>如果我们又想添加新的代办事项，而又一次不幸运的，后面的位置又有其他人占用了。于是我们又要再次转移，这样非常麻烦。</p><p>同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。</p><p>然而，这样做可以看出有2个缺点：</p><ul><li>我们额外请求的位置可能根本用上不，这样造成内存浪费。自己用不上，又不让别人用(* ￣︿￣)</li><li>如果添加的代办事项超过10个，我们还是需要转移。</li></ul><p>为了完美解决这个问题，我们可以使用<strong>链表</strong>来解决。</p><hr><h4 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h4><p>链表中的元素可存储在内存的任何地方。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="orange"><mrow><mi mathvariant="normal">链</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">每</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\color{orange}{链表的每个元素都存储了下一个元素的地址}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord" style="color:orange;"><span class="mord cjk_fallback" style="color:orange;">链</span><span class="mord cjk_fallback" style="color:orange;">表</span><span class="mord cjk_fallback" style="color:orange;">的</span><span class="mord cjk_fallback" style="color:orange;">每</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">元</span><span class="mord cjk_fallback" style="color:orange;">素</span><span class="mord cjk_fallback" style="color:orange;">都</span><span class="mord cjk_fallback" style="color:orange;">存</span><span class="mord cjk_fallback" style="color:orange;">储</span><span class="mord cjk_fallback" style="color:orange;">了</span><span class="mord cjk_fallback" style="color:orange;">下</span><span class="mord cjk_fallback" style="color:orange;">一</span><span class="mord cjk_fallback" style="color:orange;">个</span><span class="mord cjk_fallback" style="color:orange;">元</span><span class="mord cjk_fallback" style="color:orange;">素</span><span class="mord cjk_fallback" style="color:orange;">的</span><span class="mord cjk_fallback" style="color:orange;">地</span><span class="mord cjk_fallback" style="color:orange;">址</span></span></span></span></span>，从而使<strong>一系列随机的内存地址</strong>串在一起。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564546025934.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564546124422.png" alt></p><p>这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并<strong>将其地址存储到前一个元素中</strong>。只要有足够的内存空间，就能为链表分配内存。</p><p>链表当然也有自己的缺点。在需要读取链表的<strong>最后一个元素</strong>时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。</p><p>需要<strong>同时读取所有元素</strong>时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要<mark>跳跃</mark>，链表的效率真的很低。</p><hr><h4 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h4><p>排行榜网站使用卑鄙的手段来增加页面浏览量。它们不在一个页面中显示整个排行榜，而将排行榜的每项内容都放在一个页面中，并让你单击 Next来查看下一项内容。例如，显示十大电视反派时，不在一个页面中显 示整个排行榜，而是先显示第十大反派（Newman）。你必须在每个页面中单击Next，才能看到第一大反派（Gustavo Fring）。这让网站能够在10个页面中显示广告，但用户需要单击Next九次才能看到第一个，真的是很烦。 如果整个排行榜都显示在一个页面中，将方便得多。这样，用户可单击排行榜中的人名来获得更详细的信息。</p><p>由上节中链表介绍可知，若想同时读取所有元素或者跳跃读取元素时，链表不是一个好的选择。</p><p>数组与此不同：你知道其中<strong>每个元素的地址</strong>。例如，假设有一个数组，它包含五个元素，起始地址为00，那么元素#5的地址为04.</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564546723265.png" alt></p><p>需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。</p><hr><h4 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h4><p>数组的元素带编号，编号从0而不是1开始。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564546836788.png" alt></p><p>几乎所有的编程语言都从0开始对数组元素进行编号。元素的位置称为索引。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564547386674.png" alt></p><hr><h4 id="在中间插入"><a class="markdownIt-Anchor" href="#在中间插入"></a> 在中间插入</h4><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564572944803.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564572992015.png" alt></p><hr><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><p>当我们需要删除元素时，使用链表也是一个很好的选择，只需要改变前一个元素指向的地址即可。而对于数组，删除一个元素后，需要将后面的元素都向前移。</p><p>不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能够将元素删除。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564573436800.png" alt></p><p>需要注意的是，当能够立即访问到删除的元素时，删除操作的运行时间才为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><p>数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持<mark>随机访问</mark>。有两种访问方式：<strong>随机访问</strong>和<strong>顺序访问</strong>。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。</p><hr><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><h4 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h4><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564636586034.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564636614906.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564636639847.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564636670269.png" alt></p><hr><h4 id="python代码"><a class="markdownIt-Anchor" href="#python代码"></a> python代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""用于寻找列表中的最小值"""</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]  <span class="comment"># 用于存储最小值</span></span><br><span class="line">    smallest_index = <span class="number">0</span>  <span class="comment"># 存储最小值元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:  <span class="comment"># 进行大小判断，更新最小值及其索引</span></span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""list:需要进行排序操作的列表"""</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):   </span><br><span class="line">        samllest = findSmallest(arr)    <span class="comment"># 获取最小值索引</span></span><br><span class="line">        newArr.append(arr.pop(samllest))  <span class="comment"># 将最小值索引对应元素从原列表中剔除，并添加到新的排序列表中</span></span><br><span class="line">    <span class="keyword">return</span> newArr  <span class="comment"># 返回新的排序列表</span></span><br></pre></td></tr></table></figure><p>这里有几点需要注意的地方：</p><ul><li><code>pop()</code>方法默认会剔除列表中最后一项元素，并且原列表会改变<ul><li><code>arr.pop()</code>会返回被剔除的那个元素值</li><li>也可以向其传入需要剔除元素的索引</li></ul></li></ul><hr><h2 id="chapter-iii-递归"><a class="markdownIt-Anchor" href="#chapter-iii-递归"></a> Chapter Ⅲ 递归</h2><h3 id="quicklearning-递归"><a class="markdownIt-Anchor" href="#quicklearning-递归"></a> Quicklearning-递归</h3><p>递归与循环的差别：想象现在有一个大盒子，大盒子内有若干小盒子，我们现在要在这些小盒子中寻找钥匙。</p><p>循环的做法是：我们每次取出一个盒子，如果盒子里是钥匙，则任务完成；如果盒子里还是盒子，我们就把里面的盒子取出，放到大盒子中，再从大盒子中取出一个盒子，重复上述操作。</p><p>递归的做法是：我们从大盒子中取出一个小盒子，将小盒子进行详细检查，如果打开发现有钥匙，则任务完成；如果打开还是盒子，我们继续将这个里面的小盒子打开，进行详细检查，重复上述检查操作。</p><p>递归其实是方便了程序员难为了机器。它只要得到数学公式就能很方便的写出程序。优点就是易理解，容易编程。但递归是用<strong>栈机制</strong>实现的（<em>c++</em>），每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。循环其缺点就是不容易理解，编写复杂问题时困难。优点是效率高。运行时间只因循环次数增加而增加，没什么额外开销。空间上没有什么增加<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><blockquote></blockquote><hr><p>递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。</p><blockquote><p>作者在书中引用Leigh Caldwell在Stack Overflow上的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能容易理解。如何选择要看什么对你来说更重要。”</p></blockquote><hr><h3 id="基线条件和递归条件"><a class="markdownIt-Anchor" href="#基线条件和递归条件"></a> 基线条件和递归条件</h3><p>编写递归函数时，必须告诉它何时停止递归，否则函数会不断调用自身而进行无限循环。</p><p>正因为如此，每个递归函数都有两部分：<strong>基线条件</strong>（base case）和<strong>递归条件</strong>（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。</p><p>基线条件和递归条件形式如下：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564705418049.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564705447674.png" alt></p><hr><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><h4 id="quicklearning-栈"><a class="markdownIt-Anchor" href="#quicklearning-栈"></a> QuickLearning-栈</h4><p>调用栈（call stack）是一个非常重要的编程概念。调用栈不仅对编程来说很重要，使用递归时也必须理解这个概念。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564706295027.png" alt="栈"></p><blockquote><p>栈的调用原则：LIFO ( Last In First Out)</p></blockquote><hr><h4 id="调用栈"><a class="markdownIt-Anchor" href="#调用栈"></a> 调用栈</h4><p>计算机在内部使用被称为调用栈的栈。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802085317.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564707540822.png" alt></p><p>当最终主调函数没有调用其他函数，并且本身任务完成的情况下，主调函数完成自己的返回值，最终主调函数也被弹开。</p><p>由上图可知，这个栈存储了多个函数的变量，被称为调用栈。</p><hr><h4 id="递归调用栈"><a class="markdownIt-Anchor" href="#递归调用栈"></a> 递归调用栈</h4><p>递归函数也使用调用栈！</p><p>以递归中常见的阶乘函数为例，<code>factorial(n)</code>定义为:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∗</mo><mn>2</mn><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n! = n * (n-1) * ... * 2 * 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>其python代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x * factorial(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">≠</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">n\ne 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，递归会一直进行下去，<code>factorial</code>函数也会被一直调用下去。每调用一次，在调用栈中就会被叠上一层：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/1564708397105.png" alt></p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802091509.png" alt></p><p>注意，每个<code>factorial</code>函数调用都有自己的n变量。在一个函数调用中不能访问另一个的n变量。</p><p>理解了调用栈的原理，我们就在调用栈的角度上来看递归问题：</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802092050.png" alt></p><p>在使用循环时，我们定义了一个用来查找的盒子堆，我们每次从盒子堆中取出一个，如果里面有盒子，我们就把里面盒子放入盒子堆中，而取出的盒子就抛掉。在这个过程中，我们始终可以观察到盒子堆还有多少盒子待查找。</p><p><img src="https://raw.githubusercontent.com/BingoBounce/Personal_Img_Bed/master/img/20190802092619.png" alt></p><p>而使用递归，我们没有盒子堆，不过递归中会使用栈，就我们待查找的盒子放入栈中，这样我们就无需自己追踪盒子堆了。</p><p>使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择：</p><ul><li>重新编写代码，转而使用循环。</li><li>使用尾递归。</li></ul><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://blog.sina.com.cn/s/blog_62b1508e0100hcyx.html" target="_blank" rel="noopener">Helloword: 循环与递归的区别</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 图书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Figure out How &quot;spines&quot; in matplotlib works</title>
      <link href="/2019/07/26/matplotlib_spines/"/>
      <url>/2019/07/26/matplotlib_spines/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>⚠️ 为节省篇幅，本文章假设了我们已经导入所需库。另外spines在字典里的意思为脊椎，个人觉得翻译为坐标轴比较贴切。</p></blockquote><a id="more"></a><h2 id="设计图像的坐标轴spines"><a class="markdownIt-Anchor" href="#设计图像的坐标轴spines"></a> 设计图像的坐标轴(spines)</h2><h3 id="隐藏指定的spines"><a class="markdownIt-Anchor" href="#隐藏指定的spines"></a> 隐藏指定的spines</h3><p>在matplotlib的图中，默认有四个轴，两个横轴和两个竖轴，即top、bottom、left和right.</p><p><img src="https://github.com/BingoBounce/Personal_Img_Bed/blob/master/1564115742812.png?raw=true" alt="1564115742812"></p><p>如果需要隐藏某方向的轴，只需要使用如下命令：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先我们需要获得图中的四个轴axes</span></span><br><span class="line">ax = plt.gca() <span class="comment"># gca是"get current axes"的缩写</span></span><br><span class="line"><span class="comment"># 这里指定隐藏top轴</span></span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/BingoBounce/Personal_Img_Bed/blob/master/1564116232546.png?raw=true" alt="1564116232546"></p><p>上述隐藏spines的代码原理是将spines的颜色设置为<code>none</code>，相当&quot;隐形&quot;了。</p><p>⚙️  另外还有一种更加直观的方法，直接将spines设置为不可见：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.spines[<span class="string">'top'</span>].set_visible(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="设置spines位置"><a class="markdownIt-Anchor" href="#设置spines位置"></a> 设置spines位置</h3><p>除了可以隐藏spines,也可以设计spines所处的位置。其代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置left轴向外偏离图像30点</span></span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'outward'</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure><p><img src="https://github.com/BingoBounce/Personal_Img_Bed/blob/master/1564116726141.png?raw=true" alt="1564116726141"></p><p>为了指定所需x,y轴所对应的spines,我们可以进行如下设定：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置x轴对应bottom轴，y轴对应left轴</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br></pre></td></tr></table></figure><hr><p>如果我们现在想显示x,y轴是十字交叉的坐标轴，而不是像上图一样只是两个不相交的线段，那我们可以设置移动轴的位置到交叉轴指定坐标，例如这里我们指定在0处交叉：</p><blockquote><p>为使得一会儿更方便看出不同，我们先把x轴和其刻度的颜色改为黄色:</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.tick_params(axis=<span class="string">'x'</span>, colors=<span class="string">'yellow'</span>) <span class="comment"># tick_params用来设置轴的参数</span></span><br></pre></td></tr></table></figure><p>接下来，我们需要使用上述的<code>set_position()</code>方法来移动交叉轴位置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们先把right轴给隐藏</span></span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>,<span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="https://github.com/BingoBounce/Personal_Img_Bed/blob/master/1564119418042.png?raw=true" alt="1564119418042"></p><hr><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ol><li><p><a href="https://www.matplotlib.org.cn/" target="_blank" rel="noopener">看文档不会错系列-matplotlib</a></p></li><li><p><a href="http://scipy-lectures.org/intro/matplotlib/index.html" target="_blank" rel="noopener">良心教程👍scipy-lecture</a></p></li></ol><hr><h2 id="easter-egg"><a class="markdownIt-Anchor" href="#easter-egg"></a> Easter Egg</h2><blockquote><p>读不在三更五鼓，功只怕一曝十寒。——郭沫若</p></blockquote><p>我们可能在画图时会遇到坐标轴的刻度被线条遮挡，导致图的效果不是很好的情形。对于这个问题，我们可以通过改变字体大小和背景透明度的方式，使得线条和刻度同时可见。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xticklabels() + ax.get_yticklabels():</span><br><span class="line">    label.set_fontsize(<span class="number">14</span>)</span><br><span class="line">    label.set_bbox(dict(facecolor=<span class="string">'white'</span>, edgecolor=<span class="string">'None'</span>, alpha=<span class="number">0.75</span>))</span><br></pre></td></tr></table></figure><p>方法说明：</p><ul><li><code>set_fontsize()</code>:重新设置字体的大小</li><li><code>set_bbox()</code>:设置透明度相关的参数：<ul><li><code>facecolor</code>：调节 <code>bbox</code>的前景色</li><li><code>edgecolor</code>:设置边框的颜色，当为<code>None</code>时，表示无边框</li><li><code>alpha</code>设置透明度，范围<code>[0,1]</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Data Visualization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Star import is a bad idea!</title>
      <link href="/2019/07/25/import/"/>
      <url>/2019/07/25/import/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="star-import-is-a-bad-idea"><a class="markdownIt-Anchor" href="#star-import-is-a-bad-idea"></a> Star import is a bad idea!?</h2><p>Star import即<code>from &lt;module&gt; import *</code>,意味着我们可以访问<module>中所有我们想要访问的命名。</module></p><p>我们先定义如下脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># something.py</span></span><br><span class="line"></span><br><span class="line">public_variable = <span class="number">42</span></span><br><span class="line">_private_variable = <span class="number">141</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'm a public function! yay!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Ain't nobody accessing me from another module...usually"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublicClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_WeirdClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>然后我们在python解释器中执行<code>from something import *</code>，得到如下结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> something <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>public_variable</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_private_variable</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'_private_variable'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>public_function()</span><br><span class="line"><span class="string">"I'm a public function! yay!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_private_function()</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'_private_function'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = PublicClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;something.PublicClass object at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = _WeirdClass()</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'_WeirdClass'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>可以发现调用<code>_private_variable</code>时，发生名称错误。</p><p>这是因为<code>_private_variable</code>是以<code>_</code>开头的私有变量。如果想允许脚本能够访问模块中的私有变量，则需要在模块中使用<code>__all__</code>。</p><blockquote><p><code>_all__</code>是一个字符串列表，它定义了模块(或包)中的哪些名称将在模块上使用<code>from &lt;module&gt; import *</code>时导出。</p></blockquote><p>当模块中没有使用<code>__all__</code>时，则在调用模块的脚本中可以调用除带有<code>_</code>开头的私有变量外的所有名称。</p><p>于是我们再在<code>something.py</code>文件的顶部添加如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">'_private_variable'</span>, <span class="string">'PublicClass'</span>]</span><br></pre></td></tr></table></figure><p>现在，我们只能从<code>from something import *</code>中调用<code>_private_variable</code>和<code>PublicClass</code>两个名称。如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> something <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>public_variable</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'public_variable'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_private_variable</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>public_function()</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'public_function'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_private_function()</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'_private_function'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = PublicClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;something.PublicClass object at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = _WeirdClass()</span><br><span class="line">...</span><br><span class="line">NameError: name <span class="string">'_WeirdClass'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>以上是使用<code>from &lt;module&gt; import *</code>的情形。对于<code>from &lt;package&gt; import *</code>，<code>__all__</code>会处理在包内的模块，而除此之外，两者作用大致一样。因此，在我们使用<code>from &lt;package&gt; import *</code>时，<code>_all__</code>需要指定所有要加载并导入到当前命名空间的模块。</p><blockquote><p>⚠️ 在一个包中的<code>__init__.py</code>文件中我们忽略声明<code>__all__</code>时，则<code>from &lt;package&gt; import *</code>将不会导入任何东西。</p></blockquote><hr><p>python语言的简洁性是其一大特性。而python设计理念之一为：<em>Explicit is better than implicit</em>，即显式比隐式好。</p><p><code>from &lt;module&gt; import *</code>不是显式的。它没有告诉我们要导入什么，或者要将什么名称引入命名空间。而显式地指定我们需要导入的内容会更好。这样，读者(很可能是你未来的自己)就不会混淆变量/函数/类/等等的位置。</p><p>这就引出另一大特性：<em>Readability counts.</em>-代码可读性很重要。</p><p>即使我们需要导入很多名称，只要显式地指定需要导入的内容，代码也会比star import的可读性高很多。例如使用PEP 328:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> (Tk, Frame, Button, Entry, Canvas, Text, </span><br><span class="line">        LEFT, DISABLED, NORMAL, RIDGE, END)</span><br></pre></td></tr></table></figure><hr><p>此外，start import还有其他风险。</p><p>例如当模块/或包的作者决定更改<code>__all__</code>列表的内容(添加/删除列表中的内容)时:</p><ul><li>作者从<code>__all__</code>中删除了一个字符串。如果我们的代码使用了这个名称，那么代码将会引发一个NameError，并且很难找出原因。(<strong>隐藏bug的具体可能性</strong>)</li><li>作者<code>__all__</code>中添加了许多新名称字符串，然而我们可能不需要使用新名称，相当于<strong>我们在用不关心的东西填充名称空间，造成名称空间的污染</strong>。这些新名称甚至可能在我们没有意识到的情况下与其他函数或类的定义起冲突。</li></ul><p>当然，star import并不总是不好的，有时候也可以偷偷懒(●’◡’●)，这取决于我们是编写脚本还是编写需要重用的代码。</p><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ol><li><a href="https://medium.com/@s16h/importing-star-in-python-88fe9e8bd4d2" target="_blank" rel="noopener">Shahriar Tajbakhsh的博客：importing-star-in-python</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Warning </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

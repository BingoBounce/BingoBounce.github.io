{"pages":[{"title":"about","text":"About me华中科技大学大三数学与统计学院在读生。 个人兴趣： 编程 电影 音乐 篮球 旅游 交友 阅读 Future正在准备托福，雅思，希望能有出国学习的机会。 喜欢研究深度学习理论，希望能不断学习提高。 进一步巩固自身基础。 Contact me E-mail: aiden11@qq.com Wechat: TO6246","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"link","text":"","link":"/link/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"message","text":"","link":"/message/index.html"}],"posts":[{"title":"Star import is a bad idea!","text":"关于import *的一些探讨 Star import is a bad idea!?Star import即from &lt;module&gt; import *,意味着我们可以访问中所有我们想要访问的命名。 我们先定义如下脚本： # something.pypublic_variable = 42_private_variable = 141def public_function(): print(\"I'm a public function! yay!\")def _private_function(): print(\"Ain't nobody accessing me from another module...usually\")class PublicClass(object): passclass _WeirdClass(object): pass 然后我们在python解释器中执行from something import *，得到如下结果： &gt;&gt;&gt; from something import *&gt;&gt;&gt; public_variable42&gt;&gt;&gt; _private_variable...NameError: name '_private_variable' is not defined&gt;&gt;&gt; public_function()\"I'm a public function! yay!\"&gt;&gt;&gt; _private_function()...NameError: name '_private_function' is not defined&gt;&gt;&gt; c = PublicClass()&gt;&gt;&gt; c&lt;something.PublicClass object at ...&gt;&gt;&gt;&gt; c = _WeirdClass()...NameError: name '_WeirdClass' is not defined 可以发现调用_private_variable时，发生名称错误。 这是因为_private_variable是以_开头的私有变量。如果想允许脚本能够访问模块中的私有变量，则需要在模块中使用__all__。 _all__是一个字符串列表，它定义了模块(或包)中的哪些名称将在模块上使用from &lt;module&gt; import *时导出。 当模块中没有使用__all__时，则在调用模块的脚本中可以调用除带有_开头的私有变量外的所有名称。 于是我们再在something.py文件的顶部添加如下代码： __all__ = ['_private_variable', 'PublicClass'] 现在，我们只能从from something import *中调用_private_variable和PublicClass两个名称。如下： &gt;&gt;&gt; from something import *&gt;&gt;&gt; public_variable...NameError: name 'public_variable' is not defined&gt;&gt;&gt; _private_variable0&gt;&gt;&gt; public_function()...NameError: name 'public_function' is not defined&gt;&gt;&gt; _private_function()...NameError: name '_private_function' is not defined&gt;&gt;&gt; c = PublicClass()&gt;&gt;&gt; c&lt;something.PublicClass object at ...&gt;&gt;&gt;&gt; c = _WeirdClass()...NameError: name '_WeirdClass' is not defined 以上是使用from &lt;module&gt; import *的情形。对于from &lt;package&gt; import *，__all__会处理在包内的模块，而除此之外，两者作用大致一样。因此，在我们使用from &lt;package&gt; import *时，_all__需要指定所有要加载并导入到当前命名空间的模块。 ⚠️ 在一个包中的__init__.py文件中我们忽略声明__all__时，则from &lt;package&gt; import *将不会导入任何东西。 python语言的简洁性是其一大特性。而python设计理念之一为：Explicit is better than implicit，即显式比隐式好。 from &lt;module&gt; import *不是显式的。它没有告诉我们要导入什么，或者要将什么名称引入命名空间。而显式地指定我们需要导入的内容会更好。这样，读者(很可能是你未来的自己)就不会混淆变量/函数/类/等等的位置。 这就引出另一大特性：Readability counts.-代码可读性很重要。 即使我们需要导入很多名称，只要显式地指定需要导入的内容，代码也会比star import的可读性高很多。例如使用PEP 328: from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text, LEFT, DISABLED, NORMAL, RIDGE, END) 此外，start import还有其他风险。 例如当模块/或包的作者决定更改__all__列表的内容(添加/删除列表中的内容)时: 作者从__all__中删除了一个字符串。如果我们的代码使用了这个名称，那么代码将会引发一个NameError，并且很难找出原因。(隐藏bug的具体可能性) 作者__all__中添加了许多新名称字符串，然而我们可能不需要使用新名称，相当于我们在用不关心的东西填充名称空间，造成名称空间的污染。这些新名称甚至可能在我们没有意识到的情况下与其他函数或类的定义起冲突。 当然，star import并不总是不好的，有时候也可以偷偷懒(●’◡’●)，这取决于我们是编写脚本还是编写需要重用的代码。 Reference Shahriar Tajbakhsh的博客：importing-star-in-python","link":"/2019/07/25/import/"},{"title":"Figure out How \"spines\" in matplotlib works","text":"matplotlib中图像坐标轴(spines)的理解与相关个性化 :warning: 为节省篇幅，本文章假设了我们已经导入所需库。另外spines在字典里的意思为脊椎，个人觉得翻译为坐标轴比较贴切。 设计图像的坐标轴(spines)隐藏指定的spines在matplotlib的图中，默认有四个轴，两个横轴和两个竖轴，即top、bottom、left和right. 如果需要隐藏某方向的轴，只需要使用如下命令： # 首先我们需要获得图中的四个轴axesax = plt.gca() # gca是\"get current axes\"的缩写# 这里指定隐藏top轴ax.spines['top'].set_color('none') 上述隐藏spines的代码原理是将spines的颜色设置为none，相当”隐形”了。 :gear: 另外还有一种更加直观的方法，直接将spines设置为不可见： ax.spines['top'].set_visible(False) 设置spines位置除了可以隐藏spines,也可以设计spines所处的位置。其代码如下： # 设置left轴向外偏离图像30点ax.spines['left'].set_position(('outward', 30)) 为了指定所需x,y轴所对应的spines,我们可以进行如下设定： # 设置x轴对应bottom轴，y轴对应left轴ax.xaxis.set_ticks_position('bottom')ax.yaxis.set_ticks_position('left') 如果我们现在想显示x,y轴是十字交叉的坐标轴，而不是像上图一样只是两个不相交的线段，那我们可以设置移动轴的位置到交叉轴指定坐标，例如这里我们指定在0处交叉： 为使得一会儿更方便看出不同，我们先把x轴和其刻度的颜色改为黄色: ax.tick_params(axis='x', colors='yellow') # tick_params用来设置轴的参数 接下来，我们需要使用上述的set_position()方法来移动交叉轴位置： # 我们先把right轴给隐藏ax.spines['right'].set_visible(False)ax.spines['bottom'].set_position(('data',0))ax.spines['left'].set_position(('data',0)) 效果如图： Reference 看文档不会错系列-matplotlib 良心教程👍scipy-lecture Easter Egg 读不在三更五鼓，功只怕一曝十寒。——郭沫若 我们可能在画图时会遇到坐标轴的刻度被线条遮挡，导致图的效果不是很好的情形。对于这个问题，我们可以通过改变字体大小和背景透明度的方式，使得线条和刻度同时可见。 for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(14) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.75)) 方法说明： set_fontsize():重新设置字体的大小 set_bbox():设置透明度相关的参数： facecolor：调节 bbox的前景色 edgecolor:设置边框的颜色，当为None时，表示无边框 alpha设置透明度，范围[0,1]","link":"/2019/07/26/matplotlib_spines/"},{"title":"每日一记： 第1话","text":"开启每日积累的新篇章 封面：Photo by John Fowler on Unsplash 说明由于平时上课时间比较长，plus数学证明的摧残≡(▔﹏▔)≡，只能使用一些碎片时间来学习编程了，但还是会不定时出一些系统性学习的博客。 秉承着每天都积累一些新知识的初心，希望自己能够坚持下去，fighting! 第1话：参数管家——rcParams登场第一幕: 样式表的祭献我们可以使用一种创建自定义样式的方式: 通过向style.use方法传入样式表的路径或者URL链接。 另外，可以创建一个mpl_configdir/stylelib目录，并且将样式内容写入&lt;style-name&gt;.mplstyle文件中，我们就可以直接通过使用style.use(&lt;style-name&gt;)的方式来复用自定义的样式表。 mpl_configdir目录默认情况下， 应该创建在系统的matplotlib配置目录下，可以通过matplotlib.get_configdir()方法来获取目录路径。 在代码中，如果默认样式与&lt;style-name&gt;.mplstyle文件中自定义样式具有相同的名称，mpl_configdir/stylelib中的自定义样式表将覆盖由matplotlib定义的样式表。 ⚙️ &lt;style-name&gt;.mplstyle文件每一行设置一个自定义参数。假设我们创建了background.mplstyle文件： axes.titlesize : 24axes.labelsize : 20lines.linewidth : lines.markersize : 10 并且在代码中调用设置： import matplotlib.pyplot as pltplt.style.use(['background']) # 可以传递多个.mplstyle文件 第二幕如果只想为特定的代码块使用自定义样式，不希望更改全局样式，则plt.style包为我们提供了一个上下文管理器，用于将更改限制在特定的范围内。要隔离样式更改，可以编写如下内容: import matplotlib.pyplot as plt with plt.style.context(('background')): plt.plot(...) # 自定义样式绘图 第三幕：rcParams登场使用样式表自定义修改样式是一种静态方法，而设置rcParams可以动态地修改matplotlib全局样式。 rcParams是Matplotlib中具有自定义参数的全局类字典变量。Matplotlib的几乎每个方面参数都可以在这里配置，例如在同一图形上显示多个绘图时，每个绘图通过一组预定义的颜色进行颜色循环：rcParams['axes.color_cycle'] = ['r', 'k', 'c']。所有rc设置都存储在名为matplotlib的类字典变量中。 import matplotlib as mplmpl.rcParams['lines.color'] = 'r' # 设置曲线颜色为红色mpl.rcParams['lines.linewidth'] = 2 还可以使用matplotlib.rc()命令一次修改一个组中的多个设置，使用关键字参数: import matplotlib as mplmpl.rc('lines', linewidth=2, color='r') 使用matplotlib.rcdefaults()方法将会回复matplotlib默认设置。 此外，还可以通过将它们保存在名为matplotlibrc的ASCII文本文件中来指定永久自定义选项，该文件可以存储在当前目录(用于本地选项)或~/.matplotlib中(用于全局选项)。 Matplotlib使用matplotlibrc配置文件定制各种属性，我们称之为rc settings或rc parameters。我们可以通过该文件控制matplotlib中几乎所有属性的默认值:图形大小和dpi、行宽、颜色和样式、轴、轴和网格属性、文本和字体属性等等。 在这个文件中，每一行都包含一个自定义参数，例如axes.color_cycle: ['r', 'k', 'c']。 可以使用matplotlib.matplotlib_fname()方法来查找matplotlibrc文件的路径。 灵感来源 Cyrille Rossant：《Learning IPython for Interactive Computing and Data Visualization》 matplotlib docs: Customizing matplotlib","link":"/2019/08/05/note-1/"},{"title":"每日一记： 第3话","text":"matplotlib中绘图的一些小技巧(ipython生成svg,设置图像对象参数等) 封面： Photo by Jon Tyson on Unsplash 第3话： 矢量图像第一幕 矢量图显示 下列操作将在jupyter notebook中进行。 为生成矢量图，我们需要使用到IPython包中的display模块。先将所需模块导入： %matplotlib inline from IPython import displayfrom matplotlib import pyplot as plt 通过设置matplotlib在display中显示属性，来显示矢量图： display.set_matplotlib_formats('svg') 同时，也可以调整矢量图的尺寸： figsize=(5, 4)plt.rcParams['figure.figsize'] = figsize 第二幕 显示图像而不打印对象信息一般地，当我们在matplotlib中方法绘制图像时，都会同时返回一个图像对象信息和图像。 假设代码如下： plt.scatter(x, y, alpha=0.8) 得到如下图信息： 如果我们不想显示红色划线部分信息，可以在绘图方法后加上分号： plt.scatter(x, y, alpha=0.8); # # 加分号代表只显示图 返回结果如下：","link":"/2019/08/08/note-3/"},{"title":"每日一记： 第2话","text":"Cython的基础学习 封面： Photo by Patrick Hendry on Unsplash 第2话：加速吧，Cython！第一幕 Cython的优势Cython 的本质可以总结如下：Cython 是包含 C 数据类型的 Python。几乎所有 Python 代码都是合法的 Cython 代码。 （存在一些限制，但是差不多也可以。） Cython 的编译器会转化 Python 代码为 C 代码，这些 C 代码均可以调用 Python/C 的 API。Cython 中的参数和变量还可以以 C 数据类型来声明。代码中的 Python 值和 C 的值可以自由地交叉混合（intermixed）使用, 所有的转化都是自动进行。并且全面支持 Python 的异常处理工具（facilities），包括 try-except 和 try-finally，即便在其中操作 C 数据都是可以的。 第二幕 入手CythonCython可以接受几乎所有合法Python源文件，交叉混合使用Python/C。然而，C语言的编译非常重要，这也是开始的难点。 先从Hello World说起。创建一个helloworld.pyx文件，并写入： print (\"Hello world\") 然后创建一个setup.py文件，这是一个类似 Python Makefile 的文件，写入： from distutils.core import setupfrom Cython.Build import cythonizesetup( ext_modules = cythonize(\"helloworld.pyx\")) :notebook: Makefile文件关系到项目的编译规则，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率[^1]。 在命令行下构建我们的Cython文件： $ python setup.py build_ext --inplace 运行完上述命令会在你的当前目录生成一个新文件，如果系统是 Unix，文件名为 helloworld.so，如果系统是 Windows，文件名为 helloworld.pyd。 现在我们用一用刚生成的文件：打开 Python 的解释器(可以在命令行下敲入python开启解释器,前提已安装python环境)，像 import 普通文件一样直接 import 刚生成的文件： import helloworld# 返回 Hello World 第三幕 Cython的编译如果我们模块不需要额外的 C 库特殊的构件安装，那你可以在 import 时使用 Paul Prescod 和 Stefan Behnel 编写的 pyximport 模块来直接读取 .pyx 文件，而不需要编写 setup.py 文件。 它随同 Cython 一并发布和安装，可以这样使用它： # 这是在ipython中import pyximportpyximport.install()import helloworld 虽然pyximport模块支持了很多python模块的编译，但仍然有不少 Python 模块 Cython 无法编译。 这种情况下， import 机制（mechanism）会退回去读取 Python 原模块。.py 的 import 机制可按如下方式安装： pyximport.install(pyimport = True) 第四幕 更多实例给出一个寻找质数的程序，我们告诉它你需要多少个质数，程序以 Python list 的形式将这些质数返回： def primes(int kmax): cdef int n, k, i cdef int p[1000] result = [] if kmax &gt; 1000: kmax = 1000 k = 0 n = 2 while k &lt; kmax: i = 0 while i &lt; k and n % p[i] != 0: # i,k,p[],n都是C对象 i = i + 1 if i == k: p[k] = n k = k + 1 result.append(n) n = n + 1 return result 上述代码中，参数kmax是以int类型声明的。这意味着传入 kmax 的对象将会转化成 C 语言的整数变量。（如果无法转化为 int 型，将会抛出 TypeError 异常）。 第 2、3 行使用了 cdef 来定义 C 语言的局部变量。 第 11-12 行用候选数字除以已经找到的质数，这两行很有意思. 因为没有涉及 Python 对象，所以循环将会完全翻译为 C 语言代码，所以运行非常快！ 第16行中，在 twist 的作用下 C 语言定义的变量 n 在 append 方法调用前会自动转化为 Python 对象。 使用 Cython 编译器编译 primes.pyx 文件来生成一个拓展模块，我们可以在ipthon中来试用： &gt;&gt;&gt; import primes&gt;&gt;&gt; primes.primes(10)[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 第五幕 调用C函数先以一个 C 标准库中的函数为例。 我们不需要向你的代码中引入额外的依赖，Cython 都已经帮你定义好了这些函数。所以可以将这些函数直接 cimport 进来并使用。 比如说当我们想用最简单的方法将char*类型的值转化为一个整型值时， 可以使用atoi() 函数，这个函数是在stdlib.h 头文件中定义的。我们可以这样来写： from libc.stdlib cimport atoicdef parse_charptr_to_py_int(char* s): assert s is not NULL, \"byte string value is NULL\" return atoi(s) # note: atoi() has no error detection! 我们可以在 Cython 的源代码包中找到所有的标准 cimport 文件。 灵感来源 Cython官方文档中文版 [^1]:CSDN: makefile的作用是什么？","link":"/2019/08/07/note-2/"},{"title":"晨间日记","text":"投资/理财/金钱** 最宝贵的金融资产就是赚钱的本领 ** 财富阅读 这天学到了 这天记账了么 这天的思考 梦想/创意/灵感/成绩/错误** 建立灯塔与修正方向的地方 ** 今天我要尝试的是 做本月总结 灵感涂鸭 昨天的进步是 昨天的不足是 每天向前走一步，Think Big Do Small ** 成功五事** 自信积极，积累成功 ** 昨天最成功的五件事 成功在哪里/一些感言 我的一天·创意人生** 助人助己，追求卓越 ** 财富 时间 思维 感悟和收获 日历** 鼠年x岁 ** 天气 什么日子 生日 纪念日 命运日 相遇日 起床时间 睡觉日间 体重 体温 心情 亲人爱人友人-五件小事** 越是持久的关系，越需要不断的储蓄 ** 特殊的人 朋友们 家人 昨天的情感收获 健康一生·坚持为胜** 睡眠·饮食·锻炼 ** 生理周期 身体异样 锻炼项目 排便 饮食 对身体的关注和健康的理解 学无止境·参悟一生** 每周阅读一轮回，每天阅读两小时 ** 社会·环境 个体·发展 文化·兴趣 其一·它二 体会感悟 专业关注** 博大精深我在其中 ** 专业关注一 专业关注二 专业关注三 其一·它二 体会感悟","link":"/2019/08/10/晨间日记/"},{"title":"pandas_cookbook","text":"pandas库的一些食谱.本文是github项目pandas-cookbook的中文翻译项目的学习笔记，原项目链接在文章Reference中注明。 读取csv文件import pandas as pdimport matplotlib.pyplot as pltdf = pd.read_csv('xx.csv',, sep=';', encoding='latin1', parse_dates=['Date'], dayfirst=True, index_col='Date')# 'xx.csv'也可以是某个网页url sep=';'将字段分隔符改为;。字符类型，指定分隔符。默认使用”,”分割（csv文件一般以逗号分割) names: array-like 可以设置添加表头，如数据有表头，但想用新的表头，可以设置header=0,names=['a','b']实现表头定制。 header header=None表示原始文件没有列索引，这样该命令会自动加上列索引 header=0:表示文件第1行为列索引，可以添加names来替换原来的列索引(可以使用range函数) encoding='latin1'修改编码格式为'latin1' (默认是 'utf8') parse_dates=['Date']处理 ‘Date’字段的日期格式 dayfirst=True告诉pandas日期的格式是“天”在前而不是“月”在前 index_col='Date'将Date列设为索引（Index）。 index_col：指定数据中哪一列作为Dataframe的行索引,也可以指定多列形成层次索引，默认为None.系统会自动加上行索引。 其他参数： delimiter:字符类型，定界符，若指定该参数，则sep失效 skiprows=n: 忽略前n行数据 parse_dates: 布尔类型： 解析索引 列表/整数/表头(names): 如[1,2,3]-&gt;解析1，2，3列的值作为独立日期列 嵌套列表：如[[1,3]]-&gt;==合并==1，3列作为ig日期列使用字典：如{'foo':[1,3]}-&gt;将1，3列合并，合并列起名为'foo' 日期显示格式：dayfirst : boolean, default False :Day/Month格式的日期类型 # parse_dates实例# 将time1和time2两列解析为日期格式df=pd.read_csv(file_path,parse_dates=['time1','time2']) na_values= NaN: 标量/str等，设置一组用于替换NA/NaN的值 na_filter=False:boolean, default True，是否检查丢失值（空字符串或者是空值）对于大文件来说数据集中没有空值，设定na_filter=False可以提升读取速度 thousands=',': str, default None 千分位分割符，如“，”或者“.” usecols:可以指定原数据集中，所使用的列。当usecols=[0,1,2,3]时，即选中前4列，之后令第一列为行索引. nrows：可以给出从原始数据集中的所读取的行数，目前只能从第一行开始到nrows行 如果想要修改dataframe的一些列名： df.columns = [ ... ] 读取数据集的相关信息获取数据集中观察值的个数 observations = df.shape[0]# 或者observations.info() # 该方法更加推荐，可以获得详细信息 获取数据集的列数： colsNum = df.shape[1] 获取数据集所有列的名称: colsName = df.columns 获取数据集的索引情形： df_index = df.index 直接使用索引作为Dataframe属性： # 对df的col_1查看其数据类型df.col_1.dtype 将col_1数据类型进行转换： # 使用apply方法可以传入一个函数，并对数据进行操作trans = = lambda x: float(x[1:-1]) # 使用匿名函数转换df.col_1 = df.col_1.apply(trans) 切片索引将数据绘制成图像： _ = df.plot(figsize=(15,10)) 获取前1行到最后一行数据: df[1:-1] 选取第一列： df[:6][0] 选取多列数据： # 获取索引名为index1和index2的两列数据df[['index1', 'index2']] 只选取前10行： df[['index1', 'index2']][:10] 使用条件索引获取相应数据： # 获取df中索引名为index的列中，所有值为1的数据df[df['index'] == 1] # df[index] = 1得到一个布尔值列表 也可以结合布尔操作来获取条件数据： value_larger_one = (df['index'] &gt; 1)value_less_zero = (df['index'] &lt; 0)df[value_larger_one | value_less_zero ] # \"或\"条件，\"和\"条件可以使用&amp;，\"非\"：! 返回Dataframe的索引： df.index # 返回一个索引列表，以及索引的相关属性# 也可以对index重新赋值df.index = [...] pandas有一系列获取time series的函数，可以获得每一行数据对应的每个月第几天，星期几： df.index.daydf.index.weekday 统计统计每项索引数据的总数： df['index'].value_counts() 只观察最多的5项： df['index'].value_counts()[:5] 更直观地绘制柱状图： df['index'].value_counts().plot(kind='bar') Dataframe可以使用groupby()方法，对数据进行分类。也可以用作统计数据： # df.groupby('index_name').aggregate(sum) 的意思就是说，首先将数据按照索引index_name内容分组，然后对每一组的数据求和。df_counts = df.groupby('index_name').aggregate(sum)# 这里的sum函数还可以换为其他的统计函数，例如max、numpy.median,...# 也可以直接对分组对象使用sum函数df.groupby('index_name').sum() 使用dropna函数丢弃数据中一些几乎全为空的列 # dropna中的参数axis=1的意思是去掉整列而不是行# how=‘any’的意思是任何有空值的列都去掉df = df.dropna(axis=1, how='any') ⚠️ dropna函数只是将包含空值的列数据都删去，而不删除列。 如果想要删除整个列，则需要使用drop函数： # 使用drop函数，删除指定的列index1, index2df = df.drop(['index1, index2'], axis=1) # axis=1同样表示删除整列，默认是删除整行 使用resample()方法，将df数据进行重采样，可对时间序列数据重新采样和频率转换 \"\"\"参数说明： freq： 表示重采样频率，例如‘M'、‘5min'，Second(15) how：用于产生聚合值的函数名或数组函数 closed： 在降采样时，各时间段的哪一段是闭合的，‘right'或‘left'，默认‘right'\"\"\"_ = df['index'].resample('M', how=np.median) 使用sort_values方法将数据按索引进行排序： # 对分组为item的数据，根据索引index进行降序排序c = df.groupby('item')c = c.sum()c = c.sort_values(['index'], ascending=False)c.head(1) # 获取数目最多的item数据 pandas的Series与Numpy的array关系DataFrame中的每一列都是pd.Series类型的数据。pandas中Series类型的数据实际上是numpy array类型的数据，如果我们对任何Series类型的数据使用.values方法，则可以得到内部的numpy array。 pd.Series([1,2,3])\"\"\"返回结果0 11 22 3dtype: int64\"\"\"pd.Series([1,2,3]).values# array([1,2,3])np.array([1,2,3])# array([1,2,3]) 💡 数组的二值化操作：对数据进行条件判断，返回一个布尔值列表，满足条件的数据值为True,代表1；不满足的即为False，代表0. 可以将二值化向量转换为0,1表示： &gt; vec.astype(float)&gt; 💡 在python2版本中，除法是使用整除，即取整去余，而在python3中，则是返回浮点型。为了使得python2中也返回浮点型，可以导入模块from __future__ import division。 拷贝与融合数据拷贝所需的Dataframe: df_copy = df[['index']].copy() 向Dataframe中添加新的列： df.loc[:, 'index_name'] # 第二个属性是给新添加的列的索引 使用concat函数可以将所有数据融合在一起： # 将dataframe#2数据与dataframe#1融合df = pd.concat([df_1, df_2]) 字符串操作pandas提供了一些向量化的函数，来处理某些列是否包含指定字符串的问题： # 检查dataframe某列中是否包含字符串'string'is_string = df['index'].str.contains('string') # 返回了一个二值向量 将字符串切片： df = df.str.slice(start, end) # 参数为切割的索引区间，只取这个区间内的字符串 当想要对数字字符串进行排序，可以使用sort()方法： # 假设我们选取index1,index2,index3三列，并且按照index1列数字排序df[['index1','index2','index3']].sort('index1')# sort方法还可以传入参数ascending,指定排序是升序还是降序 若想将所有字符串大写，可用如下操作: df['index'].str.upper() 处理”脏”数据为了检查数据，可以先使用.unique()方法将dataframe中所有值列出来 df.unique() 当一些空值没有被pandas处理，而被转换为类似’N/A’ 和’NO CLUE’的字符串类型，则我们需要将其转换为通常的nan类型.还可能有一些数据是浮点型，而被转换为了字符串型。我们需要将所有数据都转换为string类型： # 在读取csv文件时，可以传入na_values参数来处理这些缺失值# 指定csv文件中需要转换为string类型的列indexna_values = ['NO CLUE', 'N/A', '0'] # 定义缺失值可能形式的列表df = pd.read_csv('../xx.csv', na_values=na_values, dtype={'index': str})) 时间戳处理用pandas解析时间戳最神奇的地方在于，numpy的datetimes本身就是以unix的时间戳形式保存的，因此，我们要做的就是，告诉pandas这些int型数据就是时间戳。 如果我们有一个时间段用秒或者微秒来表示的，那么直接转换datetime64类型，pandas就可以帮我们处理了。 我们可以使用pd.to_datetime函数来完成int型时间戳到datetime类型的转换: # 先将时间戳对应的列数据由字符串转换为int类型df['time_stamp'] = df['time_stamp'].astype(int) # 强制转换df['time_stamp'] = pd.to_datetime(df['time_stamp'], unit='s')# 此时，time_stamp列的数据类型变为&lt;M8[ns]，即datetime64 to_datetime函数可用指定格式化日期时间，如:pd.to_datetime('2019/8/3 10:24:48', format='%Y/%m/%d %H:%M:%S') 其中参数unit是输入数据的单位，其为字符串类型：string[D,s,ms,us,ns],默认是$’ns’$. 保存文件将数据直接保存到本地的csv文件，方便以后读取： df.to_csv('../xx/data.csv') # 存储目录 Reference🔗 Github: pandas-cookbook","link":"/2019/08/02/pandas-cookbook/"},{"title":"matplotlib tutorials","text":"matplotlib库的使用手则 Pyplot教程先导入模块: import matplotlib.pyplot as plt 打了这么多字，好累。直接看这吧😂Matplotlib 用户指南","link":"/2019/08/04/matplotlib/"},{"title":"《算法图解》学习笔记：上部","text":"本系列文章是对《算法图解》该书的一个学习性笔记。上部内容：算法简介、选择排序、大O表示法、递归。 文章中有大量图片，初次加载可能会比较慢(￣▽￣)* Chapter Ⅰ 算法简介二分查找Easy-Learning简单查找：想象我们现在正在玩猜数字的游戏。我们在0-100中猜数字，每次猜测只能排除一个数字，假设设定的猜测数为99，如果我们按照1，2，3,…顺序猜测，那么将要猜测99次才能猜中。 二分查找：当我们希望在一个很大的数据集中查找某一个数据，例如在网站数据库中寻找某一个用户名信息。如果我们从第一个用户名字母”A”开始查对，如果该用户名排名很后，将会非常耗时。然而，我们可以选择从中间字母，例如”L”字母开始查找。这种从中间开始查找的思想就是二分查找算法的核心。 二分查找算法的输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其索引位置；否则返回null。 由猜数字的例子，我们可以推导出二分查找与简单查找的步数对比：一般而言，对于包含$n$个元素的列表，用二分查找最多需要$\\log_2n$步，而简单查找最多需要$n$步。 python实现 def binary_search(list, item): \"\"\" 参数说明： list: 需要查找的值所在的列表 item: 需要查找的值 \"\"\" # 获取列表的初始两端的索引，即为查找的索引范围 low = 0 high = len(list) - 1 # 列表长度减1即为最后一个元素的索引 while low &lt;= high: # 设置终止条件，当low=high时，说明整个list都被遍历了 # 获取中间位置元素的索引 mid = int((low + high) / 2) # 在python2中会自动将mid向下取整，而pyhton3会得到浮点型，则需将其转为整数类型，也可以使用math模块的floor方法 guess = list[mid] # 选取list列表的中间值为猜测值 # 当找到匹配值时，将其索引返回 if guess == item: return mid # 条件判断：若猜测值比真实值小，则修改low,反之则修改high if guess &lt; item: low = mid + 1 else: high = mid - 1 return 0 算法运行时间一般而言，我们应选择效率最高的算法，以最大限度地减少运行时间或占用空间。 假设列表包含40亿个数字，则简单查找逐个地检查数字，最多需要猜40亿次，即最多需要猜测的次数与列表长度相同，这被称为线性时间（linear time）；而二分查找最多只需猜测32次，其运行时间为对数时间（或log时间） 大O表示法大O表示法是一种特殊的表示法，可以衡量算法的运行速度的快慢。 算法运行时间以不同速度增加假设现在Bob要为NASA(美国国家航空航天局，梦想之地ヾ(≧▽≦*)o)编写一个查找算法，帮助计算着陆地点。 Bob需要做出决定，是使用简单查找还是二分查找。使用的算法必须快速而准确。 一方面，二分查找的速度更快。Bob必须在10秒钟内找出着陆地点，否 则火箭将偏离方向。另一方面，简单查找算法编写起来更容易，因此出现bug的可能性更小。Bob可不希望引导火箭着陆的代码中有bug！为确保万无一失，Bob决定计算两种算法在列表包含100个元素的情况下需要的时间。 假设检查一个元素需要1毫秒。使用简单查找时，Bob必须检查100个元素，因此需要100毫秒才能查找完毕。而使用二分查找时，只需检查7个元素（$\\log_2100$大约为7），因此需要7毫秒就能查找完毕。 当列表包含100个元素时，简单查找需要100毫秒，而二分查找需要7毫秒，经计算，二分查找的速度大约为简单查找的15倍。而当列表元素为1000，10000，…时，这个倍数关系还是否成立？ 答案是不成立。$\\color{red}{因为二分查找和简单查找的运行时间的增速不同。}$ 也就是说，随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。当列表包含10亿个元素时，为==3300万倍==。 有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，更有意义的是知道运行时间随列表增长而增加的速度。这正是大O表示法的用武之地。 大O表示法指出了算法运行时间的增速。例如，假设列表包含n个元素。简单查找需要检查每个元素，因此需要执行n次操作。使用大O表示法，这个运行时间为$O(n)$。 而对于二分查找，为检查长度为n的列表，其需要执行$\\log n$次操作。使用大O表示法，为$O(\\log n)$. $\\log$在这里默认以2为底数。 理解不同的大O运行时间以在白纸上画网格为例： 算法1：简单查找算法实现，则是以每次画一个格式的方式，重复16次： 算法2：二分查找方式，则是每次将纸对折，然后沿着虚线画条线，则第一次对称相当于画了两个格子，重复操作。最终我们只需折4次后再打开，就得到16个格子。 可知算法1的运行时间为$O(n)$，算法2的运行时间为$O(\\log n)$。 大O表示法指出最糟情况下的运行时间例如使用简单查找方式在电话簿中查找人。如果电话簿中一共有n个电话号码，则算法最多查找n次，那么其运行时间是$O(n)$。 如果查找一次就找到了，这当然是最佳情形，但大O表示法说的是最糟的情形。在最糟情况下，必须查看电话簿中的每个条目，对应的运行时间为O(n)。这是一个保证——你知道简单查找的运行时间不可能超过O(n)。 常见的大O运行时间 $O(\\log n)$，也叫对数时间，这样的算法包括二分查找。 $O(n)$，也叫线性时间，这样的算法包括简单查找。 $O(n * \\log n)$，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。 $O(n^2)$，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。 $O(n!)$，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 对于大O表示法，我们可以得到如下启示： 算法的速度指的并非时间，而是操作数的增速。 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 算法的运行时间用大O表示法表示。 $O(\\log n)$比$O(n)$快，当需要搜索的元素越多时，前者比后者快得越多。 大O表示法的一条简单规则是，大O表示法不考虑乘以、除以、加上或减去的数字。下面这些都不是正确的大O运行时间：$O(n + 26)、O(n - 26)、O(n * 26)、O(n / 26)$，它们都应表示为$O(n)$！ 旅行商问题 对于每种顺序，他都需要计算总旅程，再挑选出旅程最短的路线。5个城市有120种不同的排列方式。因此，在涉及5个城市时，解决这个问题需要执行120次操作。涉及6个城市时，需要执行720 次操作（有720种不同的排列方式）。涉及7个城市时，需要执行5040次操作！ 推而广之，涉及n个城市时，需要执行n!（n的阶乘）次操作才能计算出结果。因此运行时间为$O(n!)$，即阶乘时间。除非涉及的城市数很少，否则需要执行非常多的操作. 这就是计算机科学领域非常著名的旅行商问题，其计算时间增加得非常快。对于这个问题，目前还没有找到更快的算法，有些很聪明的人认为这个问题根本就没有更巧妙的算法。 Chapter Ⅱ 选择排序内存的工作原理把内存想象成很多的抽屉的集合，每个抽屉都有其对应的位置，即地址。在抽屉里可以存放物体，即存储值。 当需要将数据存储到内存时，我们向计算机请求提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。 数组和链表假设我们需要编写一个管理代办事项的应用程序，需要在内存中存储一系列代办事项。 鉴于数组更容易掌握，我们先将待办事项存储在数组中。使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。 现在假设你要添加第四个待办事项，但后面的那个抽屉放着别人的东西！在这种情况下，我们只能请求计算机重新分配一块可容纳4个待办事项的内存，再将所有待办事项都移到那里。 如果我们又想添加新的代办事项，而又一次不幸运的，后面的位置又有其他人占用了。于是我们又要再次转移，这样非常麻烦。 同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。 然而，这样做可以看出有2个缺点： 我们额外请求的位置可能根本用上不，这样造成内存浪费。自己用不上，又不让别人用(* ￣︿￣) 如果添加的代办事项超过10个，我们还是需要转移。 为了完美解决这个问题，我们可以使用链表来解决。 链表链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。 这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。只要有足够的内存空间，就能为链表分配内存。 链表当然也有自己的缺点。在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。 需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要==跳跃==，链表的效率真的很低。 数组排行榜网站使用卑鄙的手段来增加页面浏览量。它们不在一个页面中显示整个排行榜，而将排行榜的每项内容都放在一个页面中，并让你单击 Next来查看下一项内容。例如，显示十大电视反派时，不在一个页面中显 示整个排行榜，而是先显示第十大反派（Newman）。你必须在每个页面中单击Next，才能看到第一大反派（Gustavo Fring）。这让网站能够在10个页面中显示广告，但用户需要单击Next九次才能看到第一个，真的是很烦。 如果整个排行榜都显示在一个页面中，将方便得多。这样，用户可单击排行榜中的人名来获得更详细的信息。 由上节中链表介绍可知，若想同时读取所有元素或者跳跃读取元素时，链表不是一个好的选择。 数组与此不同：你知道其中每个元素的地址。例如，假设有一个数组，它包含五个元素，起始地址为00，那么元素#5的地址为04. 需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。 术语数组的元素带编号，编号从0而不是1开始。 几乎所有的编程语言都从0开始对数组元素进行编号。元素的位置称为索引。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。 在中间插入 删除当我们需要删除元素时，使用链表也是一个很好的选择，只需要改变前一个元素指向的地址即可。而对于数组，删除一个元素后，需要将后面的元素都向前移。 不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能够将元素删除。 需要注意的是，当能够立即访问到删除的元素时，删除操作的运行时间才为$O(1)$。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为$O(1)$。 数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持==随机访问==。有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。 选择排序理解 python代码def findSmallest(arr): \"\"\"用于寻找列表中的最小值\"\"\" smallest = arr[0] # 用于存储最小值 smallest_index = 0 # 存储最小值元素的索引 for i in range(1, len(arr)): if arr[i] &lt; smallest: # 进行大小判断，更新最小值及其索引 smallest = arr[i] smallest_index = i return smallest_indexdef selectionSort(arr): \"\"\"list:需要进行排序操作的列表\"\"\" newArr = [] for i in range(len(arr)): samllest = findSmallest(arr) # 获取最小值索引 newArr.append(arr.pop(samllest)) # 将最小值索引对应元素从原列表中剔除，并添加到新的排序列表中 return newArr # 返回新的排序列表 这里有几点需要注意的地方： pop()方法默认会剔除列表中最后一项元素，并且原列表会改变 arr.pop()会返回被剔除的那个元素值 也可以向其传入需要剔除元素的索引 Chapter Ⅲ 递归Quicklearning-递归递归与循环的差别：想象现在有一个大盒子，大盒子内有若干小盒子，我们现在要在这些小盒子中寻找钥匙。 循环的做法是：我们每次取出一个盒子，如果盒子里是钥匙，则任务完成；如果盒子里还是盒子，我们就把里面的盒子取出，放到大盒子中，再从大盒子中取出一个盒子，重复上述操作。 递归的做法是：我们从大盒子中取出一个小盒子，将小盒子进行详细检查，如果打开发现有钥匙，则任务完成；如果打开还是盒子，我们继续将这个里面的小盒子打开，进行详细检查，重复上述检查操作。 递归其实是方便了程序员难为了机器。它只要得到数学公式就能很方便的写出程序。优点就是易理解，容易编程。但递归是用栈机制实现的（c++），每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。循环其缺点就是不容易理解，编写复杂问题时困难。优点是效率高。运行时间只因循环次数增加而增加，没什么额外开销。空间上没有什么增加[^1]。 [^1]: Helloword: 循环与递归的区别 递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。 作者在书中引用Leigh Caldwell在Stack Overflow上的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能容易理解。如何选择要看什么对你来说更重要。” 基线条件和递归条件编写递归函数时，必须告诉它何时停止递归，否则函数会不断调用自身而进行无限循环。 正因为如此，每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。 基线条件和递归条件形式如下： 栈QuickLearning-栈调用栈（call stack）是一个非常重要的编程概念。调用栈不仅对编程来说很重要，使用递归时也必须理解这个概念。 栈的调用原则：LIFO ( Last In First Out) 调用栈计算机在内部使用被称为调用栈的栈。 当最终主调函数没有调用其他函数，并且本身任务完成的情况下，主调函数完成自己的返回值，最终主调函数也被弹开。 由上图可知，这个栈存储了多个函数的变量，被称为调用栈。 递归调用栈递归函数也使用调用栈！ 以递归中常见的阶乘函数为例，factorial(n)定义为:$n! = n * (n-1) * … * 2 * 1$ 其python代码如下： def factorial(n): if x == 1: return 1 else: return x * factorial(n-1) 当$n\\ne 1$时，递归会一直进行下去，factorial函数也会被一直调用下去。每调用一次，在调用栈中就会被叠上一层： 注意，每个factorial函数调用都有自己的n变量。在一个函数调用中不能访问另一个的n变量。 理解了调用栈的原理，我们就在调用栈的角度上来看递归问题： 在使用循环时，我们定义了一个用来查找的盒子堆，我们每次从盒子堆中取出一个，如果里面有盒子，我们就把里面盒子放入盒子堆中，而取出的盒子就抛掉。在这个过程中，我们始终可以观察到盒子堆还有多少盒子待查找。 而使用递归，我们没有盒子堆，不过递归中会使用栈，就我们待查找的盒子放入栈中，这样我们就无需自己追踪盒子堆了。 使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择： 重新编写代码，转而使用循环。 使用尾递归。","link":"/2019/08/02/Algorithm-1/"},{"title":"jupyter-ipywidgets使用手册","text":"Jupyter插件ipywidgets的使用手册 封面来源:Medium: Emanuele Fabbiani 先导入模块： import ipywidgets as widgets 部件集合1.1 数值部件数值部件被设计用来显示数值。可以显示整数和浮点数，包括有界的和无界的。大部分数值小部件的参数设置都类似，例如整数滑动条(IntSlider)和浮点数滑动条(FloatSlider)，它们只是名称不同，其功能与参数大致相同。 1.1.1 整数滑动条/浮点数滑动条现在来实现一个整数滑动条： widgets.IntSlider( value=7, # 设定初始状态，滑动条的值 min=0, # 设定滑动条最小滑动值 max=10, # 设定滑动条最大滑动值 step=1, # 每次移动，改变的步数 description='Test:', # 滑动条的名称，若设置中文，则需要使用unicode编码,例如 u'中国' disabled=False, # 当设置为True时，禁止改变滑动条数值 continuous_update=False, orientation='horizontal', # 设置滑动条的方向：horizontal水平，vertical垂直,默认horizontal readout=True, # 是否显示滑动条当前数值，默认True readout_format='d' # 滑动条数值显示格式：d-整数) continuous_update的作用: 个人认为作用为是否设置连续更新值，设置为True时，每次修改滑动条数值，都会刷新当前值，并且使得编译器重新编译。而设置为False,则无需重新编译，相当于已经缓存所有滑动条数值。一般设置为False。 浮点数滑动条与整数滑动条的设置几乎一样，只需改动数值显示格式和使用的方法即可： widgets.FloatSlider( value=7.0, min=0, max=10.0, step=0.1, description='Test:', disabled=False, continuous_update=False, orientation='horizontal', readout=True, readout_format='.1f', # 设置显示的格式为显示一位小数的浮点数) 1.1.2 浮点指数滑动条我们知道指数函数的增长速度是很快的，使用指数函数可以表达很大区间长度的滑动条。 设置格式如下： widgets.FloatLogSlider( value=10, base=10, # 指数函数的底数 min=-10, # 指数函数的幂数最小值 max=10, # 指数函数的幂数最大值 step=0.2, # 幂数改变的步长 description='Log Slider') 1.1.3 整数/浮点数区间型滑动条IntRangeSlider/FloatRangeSlider可以显示一个区间值对应的滑动条，可以调节区间的大小： widgets.IntRangeSlider( value=[5, 7], # 使用列表的格式设置区间值 min=0, max=10, step=1, description='Test:', disabled=False, continuous_update=False, orientation='horizontal', readout=True, readout_format='d',) 对于浮点型，设置与整数型区间滑动条类似，可以参考浮点数滑动条。 1.1.4 整数型进度条/浮点型进度条IntProgress/FloatProgress可以展示进度条效果(静态效果)： widgets.IntProgress( # 浮动型只需改为：widgets.FloatProgress value=7, min=0, max=10, step=1, description='Loading:', bar_style='', # 'success', 'info', 'warning', 'danger' or '' orientation='horizontal') 在bar_style参数中,'success', 'info', 'warning', 'danger' or ''代表着进度条显示的不同颜色。 1.1.5 有界整数/浮点型数值输入框当需要设置输入型的数值框时，可以使用数值的Text部件： # widgets.BoundedFloatTextwidgets.BoundedIntText( value=7, min=0, max=10, step=1, description='Text:', disabled=False) BoundedIntText和BoundedFloatText输入框只能输入有界数值，如果想要输入任意数值，则可用使用IntText/FloatText: # widgets.FloatTextwidgets.IntText( value=7, description='Any:', disabled=False) 1.2 布尔控件布尔控件可以用于展示布尔类型的部件，例如未点击/已点击等。 1.2.1 开关按钮开关按钮(ToggleButton)可以设计类似灯光开关的效果，点击一次打开，再次点击则关闭： widgets.ToggleButton( value=False, # 设置初始状态，False代表开关关闭，即未点击状态 description='Click me', # 开关的描述 disabled=False, button_style='', # 'success', 'info', 'warning', 'danger' or '' tooltip='Description', # 切换按钮的提示说明,在鼠标悬停在上时显示 icon='check' # font-awesome的图标名称，显示在文字描述前) 1.2.2 复选框使用widgets.Checkbox方法可以制造复选框(checkbox)效果： widgets.Checkbox( value=False, description='Check me', disabled=False) 1.2.3 有效值valid valid部件提供只读指示器： widgets.Valid( value=False, # False代表当前值非法，True则合法 description='Valid!',) 1.3 选择部件选择部件可用于显示单个选择列表，也可用于选择多个值。我们可以通过传递列表来枚举可选选项。 1.3.1 下拉框下拉框(Dropdown)设置如下： widgets.Dropdown( options=['1', '2', '3'], value='2', # 默认值 description='Number:', disabled=False,) options可以简单设置字符串,如['Galileo', 'Brahe', 'Hubble'],或可用设置数字：[0,1,2]。 还可以设置键值对：[('Galileo', 0), ('Brahe', 1), ('Hubble', 2)]，此时我们只需设置value就能选择其对应的字符串。 1.3.2 单选框RadioButtons效果的设置也很简洁： widgets.RadioButtons( options=['pepperoni', 'pineapple', 'anchovies'], value='pineapple', description='Pizza topping:', disabled=False) RadioButtons也可以设置字符串、数字和键值对。 1.3.3 选择框widgets.Select( options=['Linux', 'Windows', 'OSX'], value='OSX', rows=3, # 可选，设置选择的行数。默认行数为options列表中选项个数 description='OS:', disabled=False) value参数可以使用index参数来代替，该参数可以设置默认值在option参数列表中的索引值。 当option设置是键值对格式时，value参数也可以使用label代替，设置为标签名，效果也一样。 1.3.4 选择滑条widgets.SelectionSlider( options=['scrambled', 'sunny side up', 'poached', 'over easy'], value='sunny side up', description='I like my eggs ...', disabled=False, continuous_update=False, orientation='horizontal', readout=True) 选择滑动条也可以使用index和label参数代替value。 1.3.5 区间型选择滑条 SelectionRangeSlider的值、索引和标签键是所选最小值和最大值的2元组。选项必须是非空的。 import datetime # 使用datetime模块格式化时间dates = [datetime.date(2015,i,1) for i in range(1,13)]options = [(i.strftime('%b'), i) for i in dates] # %b将日期格式化为 月份，如2015-3-1-&gt;Marwidgets.SelectionRangeSlider( options=options, index=(0,11), # 选择一月到十二月，元组参数 description='Months (2015)', disabled=False) index参数可以用label代替，这里index=(0,11)可以替换为label=('Jan', 'Dec')。 1.3.6 开关按钮(多个)选择部件中的ToggleButtons与布尔控件中的ToggleButton参数设置大致相同： widgets.ToggleButtons( options=['Slow', 'Regular', 'Fast'], description='Speed:', disabled=False, button_style='', # 'success', 'info', 'warning', 'danger' or '' tooltips=['Description of slow', 'Description of regular', 'Description of fast'],# icons=['check'] * 3) 1.3.7 多选框多选部件可以使用shift和ctrl(或命令)以及鼠标单击或箭头键选择多个值。 widgets.SelectMultiple( options=['Apples', 'Oranges', 'Pears'], value=['Oranges'], #rows=10, description='Fruits', disabled=False) 1.4 字符部件字符部件有接受字符，也有接受HTML和数学公式的小部件 1.4.1 字符输入框单行输入框:Text widgets.Text( value='Hello World', placeholder='Type something', # 输入框占位符 description='String:', disabled=False) 多行输入框：Textarea widgets.Textarea( value='Hello World', placeholder='Type something', description='String:', disabled=False) 1.4.2 HBox当我们想要构建多个部件的组合效果时，可以使用Hbox部件。 # value内嵌数学公式可用使用$$标识# widgets.Label()可用定义一个描述文字widgets.HBox([widgets.Label(value=\"The $m$ in $E=mc^2$:\"), widgets.FloatSlider(),widgets.IntText(value=10)]) 1.4.3 HTML部件在cell中嵌入HTML代码： widgets.HTML( value=\"Hello &lt;b&gt;World&lt;/b&gt;\", placeholder='Some HTML', description='Some HTML', # HTML代码前的描述文字) 1.4.4 HTML Math部件HTML Math部件可以同时显示HTML代码和数学公式、符号： widgets.HTMLMath( value=r\"Some math and &lt;i&gt;HTML&lt;/i&gt;: $x^2$ and $$\\frac{x+1}{x-1}$$\", # 这里使用原始字符串 placeholder='Some HTML', description='Some HTML',) 2.1 图像部件Image部件可用结合python文件读取命令来显示图像： file = open(\"Deeplearning/sheep.jpg\", \"rb\") # rb：以二进制方式读取image = file.read()widgets.Image( value=image, # 接受一个字节字符串,是想要浏览器显示的原始图像数据。 format='jpg', # 显式地选择打开图像的格式，默认为'png' width=300, height=400,) 2.2 按钮 Button部件与ToggleButton部件的显示效果差不多，不过，当Button==点击时==，颜色会变深,而当点击ToggleButton==后==，颜色保持改变。 button = widgets.Button( description='Click me', disabled=False, button_style='success', # 'success', 'info', 'warning', 'danger' or '' tooltip='Click', icon='check')toggleButton = widgets.ToggleButton( value=False, description='Click me', disabled=False, button_style='success', tooltip='Click', icon='check')buttontoggleButton 2.3 播放(动画)部件Play小部件通过以一定的速度迭代整数序列来执行动画。下面滑块的值链接到播放器: play = widgets.Play(# interval=10, 时间间隔，用来设置播放速度，默认10s value=50, min=0, # 设置范围 max=100, step=1, # 每次动画移动步长 description=\"Press play\", disabled=False)slider = widgets.IntSlider()widgets.jslink((play, 'value'), (slider, 'value')) # 前端链接两个小部件的属性，使它们保持同步widgets.HBox([play, slider]) 这里解释一下widgets.jslink部件的用法： Parameters----------source : a (Widget, &apos;trait_name&apos;) tuple for the first traittarget : a (Widget, &apos;trait_name&apos;) tuple for the second trait(指定target的某一属性的与source的同步)Examples--------&gt;&gt;&gt; c = link((widget1, &apos;value&apos;), (widget2, &apos;value&apos;)) 2.4 日期选择器DatePicker部件可以在Chrome、Firefox和IE Edge中工作，但目前不能在Safari中工作，因为它不支持HTML日期输入字段。 widgets.DatePicker( description='Pick a Date', disabled=False) 2.5 颜色选择器ColorPicker部件可以选择颜色，并且颜色名称或颜色代码： widgets.ColorPicker( concise=False, # 设置是否隐藏颜色名称或颜色代码 description='Pick a color', value='blue', disabled=False) 2.6 文件上传FileUpload部件可用以字节的形式上载任何类型的文件： widgets.FileUpload( accept='', # 选择接受的文件类型 e.g. '.txt', '.pdf', 'image/*', 'image/*,.pdf' multiple=False # 设置为True，可以接受多个文件上载) 3.1 容器/布局部件这类部件可用用来存储其他称为children的小部件。每一个容器部件在被创建时或之后，都会有被设置一个children属性。 3.1.1 Boxitems = [widgets.Label(str(i)) for i in range(4)]widgets.Box(items) HBox 全称 Horizontal Box，其中所有子项都是自动按顺序横排。VBox 则相反，全称 Vertical Box，里面为竖排方式。如果既然要水平方向和垂直方向两个方向填充内容，我们可以相互内嵌布局，即水平布局内嵌垂直布局，或垂直布局内嵌水平布局。[^1]。 [^1]: CSDN: sp42a 箱子布局攻略 (HBox/VBox Layout) 3.1.2 HBox items = [widgets.Label(str(i)) for i in range(4)]widgets.HBox(items) 3.1.3 VBox items = [widgets.Label(str(i)) for i in range(4)]left_box = widgets.VBox([items[0], items[1]])right_box = widgets.VBox([items[2], items[3]])widgets.HBox([left_box, right_box]) 3.1.4 栅格箱GridBox此框使用HTML网格规范在二维网格中布局其子元素。 # 示例在3列中列出了其中的8个数字，以及设置容纳这些数字所需的行数。items = [widgets.Label(str(i)) for i in range(8)]widgets.GridBox(items, layout=widgets.Layout(grid_template_columns=\"repeat(3, 100px)\")) # 100px代表是每列元素的横向间隔 3.1.5 折叠格Accordion部件可设置折叠效果 accordion = widgets.Accordion(children=[widgets.IntSlider(), widgets.Text()]) # 设置children部件accordion.set_title(0, 'Slider') # 折叠格的名称accordion.set_title(1, 'Text')accordion 3.1.6 选项卡Tab部件的children是在选项卡创建后，添加的属性。每一个选项的标题设置与Accordion相同： tab_contents = ['P0', 'P1', 'P2', 'P3', 'P4'] # 标题children = [widgets.Text(description=name) for name in tab_contents]tab = widgets.Tab() # 先创建Tab部件tab.children = children # 创建部件后，再添加children属性for i in range(len(children)): tab.set_title(i, str(i))tab Tab和Accordion部件在选择不同选项或者折叠格时，它们会自动更新selected_index属性，即选项对应的索引。这与之前选择部件都不同。 这意味着我们既可以查看用户正在做什么，也可以通过设置selected_index的值以编程方式设置用户看到的内容。 当设置selected_index = None关闭所有折叠格或取消选择所有选项卡。例如我们设置取消选择所有选项卡，则选项卡内部件会消失： tab..selected_index = None 3.1.7 嵌套选项卡和折叠格选项卡和折叠格可以嵌套到任意深度。下面举一例： tab_nest = widgets.Tab()accordion = widgets.Accordion(children=[widgets.IntSlider(), widgets.Text()]) # 设置children部件accordion.set_title(0, 'Slider') # 折叠格的名称accordion.set_title(1, 'Text')# 开始嵌套tab_nest.children = [accordion, accordion]tab_nest.set_title(0, 'An accordion') # 设置选项卡标题tab_nest.set_title(1, 'Copy of the accordion')tab_nest :printer: Output部件更加人性化的输出显示: IPython在IPython 5.4和6.1自动向用户提供display()，而不需要导入。如果在纯python上下文中或旧版本的IPython中使用display，请在文件顶部使用以下导入: from IPython.display import display Output部件可以捕获和显示由IPython生成的stdout、stderr和Rich output。我们还可以直接将输出追加到输出部件，或者通过编程清除它。 # 设置一个Output对象out = widgets.Output(layout={'border': '1px solid yellow'}) # 定制布局：增加输出外框 Rich output可以被定向到输出区域。在Jupyter中能够很好展示的输出都能在Output部件中很好展示： from IPython.display import YouTubeVideoout = widgets.Output(layout={'border': '1px solid yellow'})# 使用 with out 来保持Output部件的输出窗口with out: for i in range(10): print(i, 'Hello world!') display(YouTubeVideo('eWzY2nGfkXk')) # 可以展示任意部件，甚至视频 out 🔖 注意：Output部件会将所有输出都一致输出到out窗口中。 我们也可以使用append_stdout、append_stderr和append_display_data方法来将输出直接附加到output小部件。 ⚠️ 注意，append_display_data目前不能用于显示小部件. 我们可以使用IPython.display清除输出。或者我们可以直接调用小部件的clear_output方法: out.clear_output() clear_output方法可以传入wait参数，若设置为True,则clear_output方法不会直接清除输出，而是当小部件下次收到要显示的内容时，它们将被清除。这在替换output小部件中的内容时非常有用:它通过避免在调用clear_output后对小部件的大小进行不协调的调整，从而实现更平滑的转换。 交互基础的输出小部件输出部件本身也可以用来创建带有小部件和代码输出的丰富布局。定制交互UI外观的一个简单方法是使用interactive_output函数将控件连接到返回的output小部件中捕获输出的函数。 a = widgets.IntSlider(description='a')b = widgets.IntSlider(description='b')c = widgets.IntSlider(description='c')def f(a, b, c): print('{}*{}*{}={}'.format(a, b, c, a*b*c))out = widgets.interactive_output(f, {'a': a, 'b': b, 'c': c}) # 第一个参数： 交互输出函数， 第二个参数： 传递参数值widgets.HBox([widgets.VBox([a, b, c]), out]) Resource ipywidgets docs","link":"/2019/08/02/jupyter-ipywidgets/"},{"title":"《算法图解》学习笔记：中部","text":"中部内容：快速排序 Chapter Ⅳ 快速排序本章主要探索分而治之（divide and conquer，D&amp;C）——一种著名的递归式问题解决方法。 分而治之假设我们有一块土地，现在要将这块地均匀地分成方块，且分出的方块要尽可能大。 而下图中的分法都不太合适： 为了解决这个问题，我们可以使用D&amp;C策略。D&amp;C算法是递归的，其过程包括两个步骤： 找出基线条件，这种条件必须尽可能简单。 不断将问题分解（或者说缩小规模），直到符合基线条件。 对于这个问题，我们先找出基线条件。因为要将土地均匀分为方块，最容易处理的情况是，一条边的长度是另一条边的整数倍： 对于一块长50米，宽25米的土地，我们可以将这样土地分为两块$25m\\times 25m$的方块。 现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出这块地可容纳的最大方块。 以大土地的宽度640m为边长，可以得到两个最大的方块，同时余下一小块地。 我们将这两个最大方块可直接分为许多个大小均匀的方块。而对于剩下的土地，我们又可以使用相同的方法来划分，以此类推，就形成了一个递归问题。换言之，你将均匀划分$1680 m×640 m $土地的问题，简化成了均匀划分$640 m×400 m$土地的问题！ 我们再以最大宽度$400m$为边长，对剩下土地划分，于是又剩下一块$400m\\times 240m$的土地，以此递归： 最终获得问题的答案! 欧几里得算法在”分而治之”小节中引入了一种思想： 适用于这小块地的最大方块，也是适用于整块地的最大方块。这个思想的原理来自欧几里得算法(The Euclidean Algorithm). 欧几里德算法是一种快速查找两个整数的最大公因数the Greatest Common Divisor (GCD) 的技术。 算法的步骤如下： 假设现在我们需要寻找$\\mathrm{GCD}(A,B)$,即A、B的最大公因数。 如果$A=0$,那么$\\mathrm{GCD}(A,B)=B$,这是因为$\\mathrm{GCD}(0,B)=B$,则我们可以终止算法. 如果$B=0$,那么$\\mathrm{GCD}(A,B)=A$,这是因为$\\mathrm{GCD}(A,0)=A$,则我们可以终止算法. 写出A关于B的一个商余的式子(算术余子式)：$A=B·Q+R$. 因为$\\mathrm{GCD}(A,B)=\\mathrm{GCD}(B,R)$,则我们只需对$\\mathrm{GCD}(B,R)$使用欧几里得算法，即可找出A,B的gcd. 欧几里得算法利用性质:If A = B⋅Q + R and B≠0 then GCD(A,B) = GCD(B,R) ,迅速地将问题简化为越来越简单的问题，直到利用前两个性质中的一个很容易地解决为止。 而这个性质的证明可汗学院提供了一种非常直观的方式来解决[^1] [^1]: khanacademy: The Euclidean Algorithm Another example: 数组元素和给定一个数字数组：$[2,4,6]$，我们想使用递归函数来解决问题。 D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。 🔑 提示： 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时， 请检查基线条件是不是这样的。 快速排序 先使用数组第一个元素作为基准值，然后找出比基准值小的元素和比基准值大的元素。 这个操作称为分区(partitioning).现在我们获得了： 一个由所有小于基准值的数字组成的子数组； 一个由所有大于基准值的数组组成的子数组； 基准值 在进行分区后，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。 理解快速排序大致过程后，我们可能会疑问基准值如何选取呢？ 其实将任何元素用作基准值都可行: 因此我们能够对包含五个元素的数组进行排序。同理，也能够对包含六个元素的数组进行排序，以此类推。 python实现# 快速排序def quicksort(arr): if len(arr) &lt; 2: return arr # 基线条件：数组为空或只包含一个元素的数组是“有序”的 else: # 递归过程 pivot = arr[0] # 选取数组第一个元素基准值 less = [i for i in arr[1:] if i &lt;= pivot] # 比基准值小的元素组成一个数组 greater [i for i in arr[1:] if i &gt; pivot] # 比基准值大的元素组成一个数组 # 返回数组 return quicksort(less) + [pivot] + quicksort(greater) 再谈大O表示法快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。 假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。 注意，数组并没有被分成两半，相反，其中一个子数组始终为空，这导致调用栈非常长。现在假设你总是将中间的元素用作基准值，在这种情况下，调用栈如下。 现在来看看栈的第一层。你将一个元素用作基准值，并将其他的元素划分到两个子数组中。这涉及数组中的全部8个元素，因此该操作的时间为$O(n)$。在调用栈的第一层，涉及全部8个元素， 但实际上，在调用栈的每层都涉及$O(n)$个元素。 在这个示例中，层数为$O(\\log n)$（用技术术语说，调用栈的高度为$O(log n)$），而每层需要的时间为$O(n)$。因此整个算法需要的时间为$O(n) * O(\\log n) = O(n \\log n)$。这就是最佳情况。 在最糟情况下，有$O(n)$层，因此该算法的运行时间为$O(n) * O(n) = O(n^2)$。 最佳情况其实也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为$O(n \\log n)$。快速排序是最快的排序算法之一，也是D&amp;C典范。 Chapter Ⅴ 散列表散列表的引入假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。 如果本子中内容没有按字母顺序排列，那么我们可能就要一行行查找了，这样的时间复杂度就是$O(n)$了。如果本子内容是按照字母顺序排列的，那么可以使用二分查找来寻找，时间复杂度为$O(\\log n)$。 但是，如果我们能够记住所有商品价格，这样就不需要查找了，一个商品对应一个价格，即问即答，这样我们报出任何商品的价格的时间都是$O(1)$。 为了存储商品及其价格，我们可以使用前面学习到的数据结构——数组。 数组的每个元素包含两项内容：商品名和价格。如果将这个数组按商品名排序，就可使用二分查找在其中查找商品的价格。这样查找价格的时间将为$O(log n)$。然而，我们更加希望查找商品价格的时间为$O(1)$，那么散列函数就有用武之地了。 散列函数 然后，散列数列输入和输出之间必须满足一些要求： 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。 下面就展示散列函数的魅力： 散列函数准确地指出了价格的存储位置，我们根本不用查找！而散列函数原理如下： 散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。 散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。 我们结合使用散列函数和数组创建了一种被称为$\\color{red}{散列表}$（hash table）的数据结构。散列表是我们学习到的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。散列表也被称为散列映射、映射、字典和关联数组。 你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典，你可使用函数dict来创建散列表: # 创建散列表book = dict()# 添加商品价格book['apple'] = 0.67book['milk'] = 1.49book['avocado'] = 1.49# 查询商品价格book['avocado']&gt;&gt;&gt; 1.49 散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键鳄梨的价格映射到值。 实际用途1. 网站解析散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io这样的网站时，计算机必须将adit.io转换为IP地址。 这种将网址映射到IP地址的过程被称为DNS解析（DNS resolution）。 2. 避免重复假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。 如果名字在名单中，就说明这个人投过票了，因此将他拒之门外！否则，就将他的姓名加入到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。 每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办法，那就是使用散列表！ 首先创建一个散列表，由于记录已经投票的人： &gt;&gt;&gt; voted = {} 当有人来投票时，我们检查他是否在散列表中： &gt;&gt;&gt; value = voted.get(\"tom\") 如果“tom”在散列表中，函数get将返回它；否则返回None。你可使用这个函数检查来投票的人是否投过票！ 整体代表如下： voted = {}def check_voter(name): if voted.get(name): # 如果查询到名字已经在名单上 print(\"kick them out\") else: voted[name] = True print(\"let them vote!\") 散列表让我们能够迅速知道 来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。 3. 将散列表用作缓存假设我们正要访问网站facebook.com： 例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢！ 另一方面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。 为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器少做些工作，从而提高Facebook网站的访问速度呢？ 假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远？月球呢？木星呢？每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她老问你月球离地球多远，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她答案。这就是缓存的工作原理：网站将数据记住，而不再重新计算​。 如果你登录了Facebook，你看到的所有内容都是为你定制的。你每次访问facebook.com，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到的登录页面都相同。Facebook被反复要求做同样的事情：“当我注销时，请向我显示主页。”有鉴于此，它不让服务器去生成主页，而是将主页存储起来，并在需要时将其直接发送给用户。 这就是缓存，具有如下两个优点: 用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。 Facebook需要做的工作更少。 缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！ Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要将页面URL映射到页面数据。 代码与存储商品价格类型： cache = {} # 定义缓存def get_page(url): if cache.get(url): return cache[url] # 返回缓存数据 else: data = get_data_from_server(url) # 从服务器中获取数据 cache[url] = data # 将数据保存到缓存中 return data 仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。 冲突知道散列表的用途后，我们自然会想到散列表的性能如何。然而，要明白散列表的性能，我们得先搞清楚什么是冲突。 可以发现，在第一个位置已经存储了苹果的价格，这种情况下，苹果和鳄梨争夺第一个位置，这就称为冲突(collision)：给两个键分配的位置相同。 如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格，以后再查询苹果的价格时，得到的将是鳄梨的价格！冲突很糟糕，必须要避免。处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置,就在这个位置存储一个链表。 这种情况下，除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟糕：散列表的速度会很慢。 这样就引出了使用散列表的一些经验： 散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长！ 性能时间复杂度已知，一个好的散列函数很少会导致冲突，那么如果选择好的散列函数就是性能所要考虑的事情了。 本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。在平均情况下，散列表执行各种操作的时间都为$O(1)$。$O(1)$被称为常量时间。 从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。 我们将散列表和数组、链表进行对比： 在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。 因此，在使用散列表时，避开最糟情况至关重要。 为此，需要避免冲突。而要避免冲突，需要有： 较低的填装因子； 良好的散列函数 填装因子散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。 散列表的填装因子计算公式：$$填装因子 = \\frac{散列表包含的元素数}{位置总数}$$以下图为例： 总共的位置数为5，其中被占用了2个位置，根据公式可知，填装因子为$\\frac{2}{5}$。 填装因子度量的是散列表中有多少位置是空的。假设你要在散列表中存储100种商品的价格，而该散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。那么这个散列表填装因子就为$\\frac{100}{100}=1$。 如果这个散列表只有50个位置呢？填充因子将为2。不可能让每种商品都有自己的位置，因为没有足够的位置！ 填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing）。 这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。 你可能在想，调整散列表长度的工作需要很长时间！你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即便考虑到调整长度所需的时间，散列表操作所需的时间也为$O(1)$。 良好的散列函数 散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。 什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下SHA函数。你可将它用作散列函数。 小结散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。 你可以结合散列函数和数组来创建散列表 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数 平均情况下，散列表的查找、插入和删除速度都非常快 散列表适合用于模拟映射关系 一旦填装因子超过0.7，就该调整散列表的长度 散列表可用于缓存数据（例如，在Web服务器上） 散列表非常适合用于防止重复 :closed_lock_with_key: 补充——SHA算法回顾假设你有一个键，需要将其相关联的值放到数组中: 这样查找时间是固定的。当你想要知道指定键对应的值时，可再次执行散列函数，它将告诉你这个值存储在什么地方，需要的时间为$O(1)$。 比较文件另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串，SHA返回其散列值。 SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。 SHA 生成的散列值很长，这里截短了。 你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个4 GB的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送给朋友，而可计算它们的SHA散列值，再对结果进行比较。 检查密码SHA还让你能在不知道原始字符串的情况下对其进行比较。例如，假设Gmail遭到攻击，攻击者窃取了所有的密码！你的密码暴露了吗？没有，因为Google存储的并非密码，而是密码的SHA散列值！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。 Google只是比较散列值，因此不必存储你的密码！SHA被广泛用于计算密码的散列值。这种散列算法是单向的。你可根据字符串计算出散列值。 这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码转换为散列值，但反过来不行。 SHA实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。 当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。","link":"/2019/08/06/Algorithm-2/"}],"tags":[{"name":"Warning","slug":"Warning","link":"/tags/Warning/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"教程","slug":"教程","link":"/tags/教程/"},{"name":"每日一记","slug":"每日一记","link":"/tags/每日一记/"},{"name":"晨间日记","slug":"晨间日记","link":"/tags/晨间日记/"},{"name":"pandas-cookbook","slug":"pandas-cookbook","link":"/tags/pandas-cookbook/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"图书","slug":"图书","link":"/tags/图书/"},{"name":"Jupyter Widgets","slug":"Jupyter-Widgets","link":"/tags/Jupyter-Widgets/"}],"categories":[{"name":"python","slug":"python","link":"/categories/python/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/categories/Data-Visualization/"},{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"pandas","slug":"pandas","link":"/categories/pandas/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Jupyter","slug":"Jupyter","link":"/categories/Jupyter/"}]}